----------------------------------------------- -*- text -*-
-- Langage MiniJava : Sous-ensemble du langage Java pour le projet STL 2016-2017
-- Sémantique : Construction de l'arbre abstrait
--                      Gestion de la table des symboles
--                      Typage
--                      Calcul des déplacements (Allocation mémoire)
--                      Génération de code TAM
-----------------------------------------------
option auto= true;
option version = 0.0.1 ;
option k=2;


--inh factory   : BlockFactory for Type, SuiteArgumentsGenericite, ArgumentGenericite, ArgumentsGenericite, InstanceGenericite, Parametre, SuiteParametres, Parametres, Genericite, HeritageClasse, SuiteParametresGenericite, ImplantationInterface, ParametresGenericite, TypeAtomique, SuiteTypeAtomique,ParametreGenericite, Interfaces, Interface, HeritageInterface, SuiteHeritageInterface, Signature, Classes, Classe, ElementClasse, AttributOuMethode, SuiteAttributOuMethode, Constructeur, Principale, MethodePrincipale, Bloc, Instructions, Instruction, Expression, SuiteExpressions, SuiteConditionnelle, Affectation, SuiteAffectation,Condition, SuiteCondition, SuiteTerme, Facteur, SuiteFacteur, Valeur, SuiteNouveau, Acces, ElementsClasse ;

--inh factory   : BlockFactory for Interfaces, Interface,ElementsInterface,ElementInterface, HeritageInterface, SuiteHeritageInterface, Signature, Parametre, TypeAtomique, SuiteTypeAtomique, ArgumentGenericite, Parametres;
--inh tds     : SymbolTable for Interfaces, Interface, ElementsInterface, ElementInterface, HeritageInterface, SuiteHeritageInterface, Parametre, ArgumentGenericite, Parametres;

--inh tds       : SymbolTable for Expressions, ArgumentGenericite, Programme, ParametreGenericite, Interfaces, Interface, HeritageInterface, SuiteHeritageInterface, ElementsInterface, Signature, Classes, Classe, HeritageClasse, ImplantationInterface, Principale, MethodePrincipale, Genericite, ParametresGenericite, SuiteParametresGenericite, SuiteHeritageGenericite, InstanceGenericite, ArgumentsGenericite, SuiteArgumentsGenericite, ElementClasse, Constructeur, AttributOuMethode, SuiteAttributOuMethode, Type, TypeAtomique, Parametres, Parametre, SuiteParametres, Bloc, Instructions, Instruction, Expression, SuiteExpressions, SuiteConditionnelle, Affectation, SuiteAffectation, Condition, SuiteCondition, SuiteTerme, Facteur, SuiteFacteur, SuiteNouveau, Arguments, Appel, Acces, ElementsClasse, AppelOuAcces  ;


--inh support     : Expression for Acces, Appel, AppelOuAcces;
--inh gauche  : Expression for SuiteCondition, SuiteAffectation, SuiteTerme, SuiteFacteur;
--inh alors : Block for SuiteConditionnelle;
--inh condition : Expression for SuiteConditionnelle; 
--inh innerArray : Type for SuiteTypeAtomique;
--inh type    : Type for SuiteNouveau; --Hh
--inh list    : LinkedList<Objet> for Interfaces;
--inh list    : LinkedList<Objet> for Classes;
--inh list    : LinkedList<Instruction> for Instructions;


--syn ast     : Objet for Interface;
--syn ast     : Objet for Classe;
--syn ast     : LinkedList<Objet> for Interfaces;
--syn ast     : LinkedList<Objet> for Classes;
--syn ast     : Expression for Expression, Affectation, SuiteAffectation, Facteur, SuiteFacteur, Condition, SuiteCondition, SuiteTerme, Acces, SuiteNouveau;
--syn ast     : Type for Type, TypeAtomique, SuiteTypeAtomique;
--syn ast     : Type for HeritageClasse;
--syn ast     : Block for Programme;
--syn ast     :Block for MethodePrincipale, Bloc, SuiteConditionnelle; --Hh
--syn ast     : Instruction for Instruction;
--syn ast     : ParametreGenericite for ParametreGenericite; --Euuuuuuh
--syn ast     : LinkedList<ParametreGenericite> for  ParametresGenericite, Genericite, SuiteParametresGenericite;
--syn ast     : LinkedList<ParametreGenericite> for Genericite;
--syn ast 	: ArgumentGenericite for ArgumentGenericite;
--syn ast     : LinkedList<ArgumentGenericite> for InstanceGenericite, ArgumentsGenericite, SuiteArgumentsGenericite;
--syn ast     : ElementInterface for ElementInterface, Signature;
--syn ast     : LinkedList<Type> for HeritageInterface, SuiteHeritageInterface;
--syn ast     : LinkedList<ElementInterface> for ElementsInterface;
--syn ast     : LinkedList<Parametre> for Parametres, SuiteParametres;
--syn ast     : LinkedList<ElementClasse> for ElementsClasse;
--syn ast     : Parametre for Parametre;
--syn ast     : Value for Valeur; 
--syn ast     : Classe for Principale;
--syn expressions : LinkedList<Expression> for Expressions, SuiteExpressions;
--syn acces   : DroitAcces for DroitAcces ;
--syn bin_op  : BinaryOperator for Comparatif, Additif;


--Interface(Interfaces, Interface)
inh factory       : BlockFactory for Interface, Interfaces;
inh tdsInterfaces : SymbolTable for Interface, Interfaces;
inh tdsClasses    : SymbolTable for Interface, Interfaces;
inh tdsFunctions  : FunctionSymbolTable for Interface, Interfaces;
inh tdsAttributs  : SymbolTable for Interface, Interfaces;
inh tds		        : SymbolTable for Interface, Interfaces;
syn ast 	        : Interface	for Interface;
syn ast         	: LinkedList<Interface> for Interfaces;

--Heritage Interface (HeritageInterface, HeritageInterfaces,SuiteHeritageInterface)
inh tds         	         : SymbolTable for HeritageInterface, SuiteHeritageInterface;
inh factory                : BlockFactory for HeritageInterface, SuiteHeritageInterface;
inh tdsInterfaces          : SymbolTable for HeritageInterface, SuiteHeritageInterface;
inh listInterfacesHeritage : LinkedList<String> for SuiteHeritageInterface;
syn ast 	                 : LinkedList<Interface> for HeritageInterface, SuiteHeritageInterface; --


--Element Interface (ElementInterface, ElementsInterface)
inh factory             : BlockFactory for ElementInterface, ElementsInterface;
inh tds		              : SymbolTable for ElementInterface, ElementsInterface;
inh tdsAttributs        : SymbolTable for ElementInterface, ElementsInterface;
inh tdsInterfaces       : SymbolTable for ElementInterface, ElementsInterface;
inh tdsClasses          : SymbolTable for ElementInterface, ElementsInterface;
inh tdsFunctions        : FunctionSymbolTable for ElementInterface, ElementsInterface;
inh interfaceCourrante  : String for ElementsInterface, ElementInterface;
syn ast 	              : ElementInterface for ElementInterface;
syn ast 	              : LinkedList<ElementInterface> for ElementsInterface;


--Signature
inh tds 	             : SymbolTable for Signature;
inh tdsInterfaces      : SymbolTable for Signature;
inh tdsClasses         : SymbolTable for Signature;
inh tdsFunctions       : FunctionSymbolTable for Signature;
inh tdsAttributs       : SymbolTable for Signature;
inh factory            : BlockFactory for Signature;
inh interfaceCourrante : String for Signature;
syn ast 	             : Signature for Signature;

-- --Genericite (Genericite,InstanceGenericite, ArgumentGenericite, ArgumentsGenericite, SuiteArgumentsGenericite,
-- --            ParametresGenericite, SuiteParametresGenericite, ParametreGenericite, HeritageGenericite, SuiteHeritageGenericite)
-- inh tds		  : SymbolTable for Genericite, InstanceGenericite, ArgumentGenericite, ArgumentsGenericite, SuiteArgumentsGenericite, ParametresGenericite, SuiteParametresGenericite, ParametreGenericite, HeritageGenericite, SuiteHeritageGenericite;
-- inh factory : BlockFactory for Genericite, InstanceGenericite, ArgumentGenericite, ArgumentsGenericite, SuiteArgumentsGenericite, ParametresGenericite, SuiteParametresGenericite, ParametreGenericite, HeritageGenericite, SuiteHeritageGenericite;
-- syn ast 	  : ArgumentGenericite for ArgumentGenericite;
-- syn ast     : ParametreGenericite for ParametreGenericite;
-- syn ast 	  : LinkedList<ParametreGenericite> for Genericite, ParametresGenericite, SuiteParametresGenericite; -- Changé temporairement (on a pas ParamGen..LinkedList<ArgumentGenericite>.) -> LinkedList<ParametreGenericite> for Genericite;
-- syn ast 	  : LinkedList<Type> for ArgumentsGenericite, SuiteArgumentsGenericite;
-- syn ast 	  : LinkedList<Type> for InstanceGenericite;
-- syn ast     : LinkedList<Type> for HeritageGenericite, SuiteHeritageGenericite;

--Parametre (Parametres, SuiteParametres)
inh tds 	        : SymbolTable for Parametre, Parametres, SuiteParametres;
inh tdsClasses    : SymbolTable for Parametre, Parametres, SuiteParametres; --Hh
inh tdsInterfaces : SymbolTable for Parametre, Parametres, SuiteParametres;
inh tdsFunctions  : FunctionSymbolTable for Parametre, Parametres, SuiteParametres;
inh tdsAttributs  : SymbolTable for Parametre, Parametres, SuiteParametres;
inh tdsParametres : SymbolTable for Parametre, Parametres, SuiteParametres;
inh factory       : BlockFactory for Parametre, Parametres, SuiteParametres;
syn ast 	        : Parametre for Parametre;
syn ast 	        : LinkedList<Parametre> for Parametres, SuiteParametres;

--Classe (Classe, Classes)
inh tdsInterfaces : SymbolTable for Classes, Classe;
inh tdsFunctions  : FunctionSymbolTable for Classes, Classe;
inh tdsAttributs  : SymbolTable for Classes, Classe;
inh tdsClasses    : SymbolTable for Classes, Classe;
inh tds           : SymbolTable for Classes, Classe;
inh factory       : BlockFactory for Classe,Classes;
syn ast           : LinkedList<Classe> for Classes;
syn ast           : Classe for Classe;


--Implantation Interface
syn ast           : LinkedList<Interface> for ImplantationInterface;
inh tds           : SymbolTable for ImplantationInterface;
inh tdsClasses    : SymbolTable for ImplantationInterface;
inh tdsAttributs  : SymbolTable for ImplantationInterface;
inh tdsInterfaces : SymbolTable for ImplantationInterface;
inh tdsFunctions  : FunctionSymbolTable for ImplantationInterface;
inh factory       : BlockFactory for ImplantationInterface;
inh listInterfacesHeritage : LinkedList<String> for ImplantationInterface;

--Heritage Classe
syn ast           : LinkedList<Classe> for HeritageClasse;
inh tds           : SymbolTable for HeritageClasse;
inh tdsClasses    : SymbolTable for HeritageClasse;
inh tdsAttributs  : SymbolTable for HeritageClasse;
inh tdsInterfaces : SymbolTable for HeritageClasse;
inh tdsFunctions  : FunctionSymbolTable for HeritageClasse;
inh factory       : BlockFactory for HeritageClasse;

--Elements Classe (ElementClasse, AttributOuMethode, Constructeur)
inh factory       : BlockFactory for ElementsClasse,ElementClasse, AttributOuMethode, SuiteAttributOuMethode, Constructeur;
inh classeCourrante : String for ElementsClasse, ElementClasse, AttributOuMethode, SuiteAttributOuMethode, Constructeur;
syn ast           : ElementClasse for ElementClasse, AttributOuMethode, Constructeur, SuiteAttributOuMethode;
syn ast           : LinkedList<ElementClasse> for ElementsClasse;
inh tds           : SymbolTable for AttributOuMethode,SuiteAttributOuMethode, Constructeur, ElementsClasse, ElementClasse;
inh tdsClasses    : SymbolTable for AttributOuMethode,SuiteAttributOuMethode, Constructeur, ElementsClasse, ElementClasse;
inh tdsAttributs  : SymbolTable for AttributOuMethode,SuiteAttributOuMethode, Constructeur, ElementsClasse, ElementClasse;
inh tdsInterfaces : SymbolTable for AttributOuMethode,SuiteAttributOuMethode, Constructeur, ElementsClasse, ElementClasse;
inh tdsFunctions  : FunctionSymbolTable for AttributOuMethode,SuiteAttributOuMethode, Constructeur, ElementsClasse, ElementClasse;
inh droit         : DroitAcces for ElementClasse,AttributOuMethode,SuiteAttributOuMethode,Constructeur;
inh ident         : String for SuiteAttributOuMethode;
inh static        : boolean for AttributOuMethode,SuiteAttributOuMethode;
inh type          : Type for SuiteAttributOuMethode;


--DroitAcces
syn acces           : DroitAcces for DroitAcces;

--Type (Atomique,SuiteAtomique)
inh tdsInterfaces : SymbolTable for Type, TypeAtomique, SuiteTypeAtomique;
inh tdsClasses    : SymbolTable for Type, TypeAtomique, SuiteTypeAtomique;
inh tdsFunctions  : FunctionSymbolTable for Type, TypeAtomique, SuiteTypeAtomique;
inh tdsAttributs  : SymbolTable for Type, TypeAtomique, SuiteTypeAtomique;
inh tds           : SymbolTable for Type, TypeAtomique, SuiteTypeAtomique;
inh factory       : BlockFactory for Type, TypeAtomique, SuiteTypeAtomique;
inh innerArray    : Type for SuiteTypeAtomique;
syn ast 	        : Type for Type, TypeAtomique, SuiteTypeAtomique;

--Principale, Methode Principale
inh factory       : BlockFactory for Principale, MethodePrincipale;
inh tdsInterfaces : SymbolTable for Principale, MethodePrincipale;
inh tdsClasses    : SymbolTable for Principale, MethodePrincipale;
inh tdsFunctions  : FunctionSymbolTable for Principale, MethodePrincipale;
inh tdsAttributs  : SymbolTable for Principale, MethodePrincipale;
inh tds           : SymbolTable for Principale, MethodePrincipale;
syn ast           : ClassePrincipale for Principale;
syn ast           : Block for MethodePrincipale;


-- Bloc
inh factory       : BlockFactory for Bloc;
inh tds           : SymbolTable for Bloc;
inh tdsInterfaces : SymbolTable for Bloc;
inh tdsClasses    : SymbolTable for Bloc;
inh tdsFunctions  : FunctionSymbolTable for Bloc;
inh tdsAttributs  : SymbolTable for Bloc;
syn ast           : Block for Bloc;

--Expression, Expressions, SuiteExpressions
inh factory       : BlockFactory for Expression, Expressions, SuiteExpressions;
inh tdsInterfaces : SymbolTable for Expression, Expressions, SuiteExpressions;
inh tdsClasses    : SymbolTable for Expression, Expressions, SuiteExpressions;
inh tdsFunctions  : FunctionSymbolTable for Expression, Expressions, SuiteExpressions;
inh tdsAttributs  : SymbolTable for Expression, Expressions, SuiteExpressions;
inh tds           : SymbolTable for Expression, Expressions, SuiteExpressions;
inh droiteAffectation : boolean for Expression; --Hh Acces lorsqu'on est à droite du signe =. (à surveiller)
syn ast           : Expression for Expression;
syn ast           : LinkedList<Expression> for Expressions, SuiteExpressions; --Hh
--syn expressions   : LinkedList<Expression> for Expressions, SuiteExpressions; ça pue

-- Instruction, Instructions
inh factory       : BlockFactory for Instruction, Instructions;
inh tdsInterfaces : SymbolTable for Instruction, Instructions;
inh tdsClasses    : SymbolTable for Instruction, Instructions;
inh tdsFunctions  : FunctionSymbolTable for Instruction, Instructions;
inh tdsAttributs  : SymbolTable for Instruction, Instructions;
inh tds           : SymbolTable for Instruction, Instructions;
syn ast           : Instruction for Instruction;
syn list          : LinkedList<Instruction> for Instructions;

-- Condition, SuiteCondition, SuiteConditionnelle,
inh alors         : Block for SuiteConditionnelle;
inh condition     : Expression for SuiteConditionnelle;
inh factory       : BlockFactory for Condition, SuiteConditionnelle, SuiteCondition;
inh tdsInterfaces : SymbolTable for Condition, SuiteConditionnelle, SuiteCondition;
inh tdsClasses    : SymbolTable for Condition, SuiteConditionnelle, SuiteCondition;
inh tdsFunctions  : FunctionSymbolTable for Condition, SuiteConditionnelle, SuiteCondition;
inh tdsAttributs  : SymbolTable for Condition, SuiteConditionnelle, SuiteCondition;
inh tds           : SymbolTable for Condition, SuiteConditionnelle, SuiteCondition;
syn ast           : Instruction for SuiteConditionnelle;
syn ast           : Expression for Condition, SuiteCondition;
inh gauche        : Expression for SuiteCondition;
inh droiteAffectation : boolean for Condition, SuiteCondition;

-- Comparatif, Additif, Multiplicatif
syn bin_op        : BinaryOperator for Comparatif, Multiplicatif, Additif;

-- Terme, SuiteTerme
inh gauche        : Expression for SuiteTerme;
inh factory       : BlockFactory for Terme, SuiteTerme;
inh tdsInterfaces : SymbolTable for Terme, SuiteTerme;
inh tdsClasses    : SymbolTable for Terme, SuiteTerme;
inh tdsFunctions  : FunctionSymbolTable for Terme, SuiteTerme;
inh tdsAttributs  : SymbolTable for Terme, SuiteTerme;
inh tds           : SymbolTable for Terme, SuiteTerme;
inh droiteAffectation : boolean for Terme, SuiteTerme;
syn ast           : Expression for Terme, SuiteTerme;

--Facteur, SuiteFacteur
inh gauche        : Expression for SuiteFacteur;
inh factory       : BlockFactory for Facteur, SuiteFacteur;
inh tdsInterfaces : SymbolTable for Facteur, SuiteFacteur;
inh tdsClasses    : SymbolTable for Facteur, SuiteFacteur;
inh tdsFunctions  : FunctionSymbolTable for Facteur, SuiteFacteur;
inh tdsAttributs  : SymbolTable for Facteur, SuiteFacteur;
inh tds           : SymbolTable for Facteur, SuiteFacteur;
inh droiteAffectation : boolean for Facteur, SuiteFacteur;
syn ast           : Expression for Facteur, SuiteFacteur;

-- Affectation, SuiteAffectation
inh gauche        : Expression for SuiteAffectation;
inh factory       : BlockFactory for Affectation, SuiteAffectation;
inh tdsInterfaces : SymbolTable for Affectation, SuiteAffectation;
inh tdsClasses    : SymbolTable for Affectation, SuiteAffectation;
inh tdsFunctions  : FunctionSymbolTable for Affectation, SuiteAffectation;
inh tdsAttributs  : SymbolTable for Affectation, SuiteAffectation;
inh tds           : SymbolTable for Affectation, SuiteAffectation;
inh droiteAffectation : boolean for Affectation, SuiteAffectation;
syn ast           : Expression for Affectation, SuiteAffectation;

-- SuiteNouveau
inh type          : Type for SuiteNouveau;
inh factory       : BlockFactory for SuiteNouveau;
inh tdsInterfaces : SymbolTable for SuiteNouveau;
inh tdsClasses    : SymbolTable for SuiteNouveau;
inh tdsFunctions  : FunctionSymbolTable for SuiteNouveau;
inh tdsAttributs  : SymbolTable for SuiteNouveau;
inh tds           : SymbolTable for SuiteNouveau;
syn ast           : Expression for SuiteNouveau;

-- Valeur
inh factory       : BlockFactory for Valeur;
inh tdsInterfaces : SymbolTable for Valeur;
inh tdsClasses    : SymbolTable for Valeur;
inh tdsFunctions  : FunctionSymbolTable for Valeur;
inh tdsAttributs  : SymbolTable for Valeur;
inh tds           : SymbolTable for Valeur;
syn ast           : Expression for Valeur;

-- Acces AppelOuAcces
inh factory       : BlockFactory for Acces, AppelOuAcces, Appel;
inh tdsInterfaces : SymbolTable for Appel, AppelOuAcces, Acces;
inh tdsClasses    : SymbolTable for Appel, AppelOuAcces, Acces;
inh tdsFunctions  : FunctionSymbolTable for Appel, AppelOuAcces, Acces;
inh tdsAttributs  : SymbolTable for Appel, AppelOuAcces, Acces;
inh tds           : SymbolTable for Appel, AppelOuAcces, Acces;
inh support       : Expression for Acces, AppelOuAcces, Appel;
inh droiteAffectation : boolean for Acces, AppelOuAcces, Appel;
syn ast           : Expression for Acces, AppelOuAcces, Appel;

-- Arguments
inh factory       : BlockFactory for Arguments;
inh tdsInterfaces : SymbolTable for Arguments;
inh tdsClasses    : SymbolTable for Arguments;
inh tdsFunctions  : FunctionSymbolTable for Arguments;
inh tdsAttributs  : SymbolTable for Arguments;
inh tds           : SymbolTable for Arguments;
syn ast           : LinkedList<Expression> for Arguments; 

--Programme
syn ast 	: Programme for Programme;



space separateur        is    "[\n\r\t ]+";
space commentaire       is    "\/\/.*\n";
sugar accolade_ouvrante     is    "\{";  
sugar accolade_fermante     is    "\}";  
sugar crochet_ouvrant     is    "\[";  
sugar crochet_fermant     is    "\]";  
sugar parenthese_ouvrante   is    "\(";
sugar parenthese_fermante   is    "\)";
sugar inferieur         is    "\<";  
sugar superieur         is    "\>";  
sugar inferieur_egal      is    "\<=";  
sugar superieur_egal      is    "\>=";  
sugar point           is    "\.";  
sugar point_virgule       is    ";";  
sugar virgule         is    ",";
sugar affectation       is    "=";
sugar egalite         is    "==";  
sugar different         is    "\!=";  
sugar addition          is    "\+";
sugar soustraction        is    "\-";
sugar ou            is    "\|\|";  
sugar multiplication      is    "\*";
sugar division          is    "/";
sugar modulo          is    "%";
sugar adresse         is    "&";  
sugar negation          is    "\!";  
sugar et            is    "&&";  
sugar vrai            is    "true";
sugar faux            is    "false";
sugar si            is    "if";
sugar sinon           is    "else";
sugar afficher          is    "print";  
sugar nouveau         is    "new";  
sugar tant_que          is    "while";  
sugar retour          is    "return";  
sugar type_int          is    "int";
sugar type_bool         is    "boolean";  
sugar type_char         is    "char";        
sugar type_String       is    "String";        
sugar vide            is    "void";     
sugar nul           is    "null";     
sugar choix           is    "\?";         
sugar deux_points       is    ":";          
sugar interface         is    "interface";     
sugar classe          is    "class";      
sugar extension         is    "extends";      
sugar implantation        is    "implements";      
sugar public          is    "public";    
sugar protege         is    "protected";    
sugar prive           is    "private";     
sugar statique          is    "static";       
sugar final           is    "final";       
sugar principale        is    "main";  
term   chaine         is    "\"([^\"]|\\\")*\"";  
term   caractere        is    "\'[^\']\'";  
term   entier         is    "[0-9]+";
term   identificateur     is    "[a-z_][a-zA-Z0-9_]*"; 
term   identificateur_type    is    "[A-Z][a-zA-Z0-9_]*"; 



Programme -> #factory Interfaces #factory2 Classes #factory3 Principale #ast3 ;
global
  tds_Interfaces :SymbolTable;
  tds_Classes : SymbolTable;
  tds_Functions : FunctionSymbolTable;
  tds_Attributs : SymbolTable;

#factory {
do
  tds_Interfaces := new SymbolTable();
  tds_Classes := new SymbolTable();
  tds_Functions := new FunctionSymbolTable();
  tds_Attributs := new SymbolTable();

  Interfaces^tdsInterfaces := tds_Interfaces;
  Interfaces^tdsClasses := tds_Classes;
  Interfaces^tdsFunctions := tds_Functions;
  Interfaces^tdsAttributs := tds_Attributs;
  Interfaces^tds := new SymbolTable();
  Interfaces^factory := new BlockFactoryImpl();
  
end
}
#factory2 {
do
  Classes^tdsInterfaces := tds_Interfaces;
  Classes^tdsClasses := tds_Classes;
  Classes^tdsFunctions := tds_Functions;
  Classes^tdsAttributs := tds_Attributs;
  Classes^tds := new SymbolTable();
  Classes^factory := new BlockFactoryImpl();
end
}

#factory3 {
do
  Principale^tdsInterfaces := tds_Interfaces;
  Principale^tdsClasses := tds_Classes;
  Principale^tdsFunctions := tds_Functions;
  Principale^tdsAttributs := tds_Attributs;
  Principale^tds := new SymbolTable();
  Principale^factory := new BlockFactoryImpl();
end
}
#ast3 {
local
  facto : BlockFactory;
do
  facto := new BlockFactoryImpl();
  Programme^ast := facto.createProgramme(Interfaces^ast,Classes^ast,Principale^ast);
end
}



Interfaces -> Interface #interfaceMultiple Interfaces #ast;
#interfaceMultiple{
do
  if (Interfaces^tdsInterfaces.contains(Interface^ast.getName())) then
    error(INTERFACE_already_defined, Interface^ast.getName());
  else
    Interfaces^tdsInterfaces.register(Interface^ast);
  end
end
}


#ast{
do
  Interfaces1^ast.addFirst(Interface^ast);
  Interfaces^ast := Interfaces1^ast;
end
}


Interfaces -> #ast;
#ast {
do
  Interfaces^ast := new LinkedList<Interface>();
end
}



--interface identificateur_type Genericit HeritageInterface [...]
Interface -> interface identificateur_type HeritageInterface accolade_ouvrante #inh ElementsInterface accolade_fermante #ast;
#inh {
do
  ElementsInterface^tds := new SymbolTable(); -- Dans règle l228 ?
  ElementsInterface^interfaceCourrante := identificateur_type^txt;
end
}
#ast {
local
  interface : Interface;
do
  interface := Interface^factory.createInterface(identificateur_type^txt, HeritageInterface^ast, ElementsInterface^ast);
  Interface^ast := interface;
end 
}

--#ast {
--do
--  if (Interface^tds.knows(identificateur_type^txt)) then
--    error(TYPE_already_defined, identificateur_type^txt);
--  else
--    if Genericite^ast = nil then
--      if HeritageInterface^ast = nil then
--        Interface^ast := Interface^factory.createInterface(identificateur_type^txt, ElementsInterface^ast);
--      else
--        Interface^ast := Interface^factory.createInterface(HeritageInterface^ast, identificateur_type^txt,ElementsInterface^ast);
--      end
--    else
--      if HeritageInterface^ast = nil then   --Genericite^ast est un Type ?
--        Interface^ast := Interface^factory.createInterface(identificateur_type^txt,Genericite^ast,ElementsInterface^ast);
--      else
--        Interface^ast := Interface^factory.createInterface(identificateur_type^txt, Genericite^ast, HeritageInterface^ast, ElementsInterface^ast);
--      end
--    end
--  end
--end
--}



-- extension identificateur_type InstanceGenericite [...]
HeritageInterface -> extension identificateur_type #inh SuiteHeritageInterface #ast ;
-- #ast{
-- local
--   o : Optional<Declaration>;
--   d : Declaration;
-- do
--   HeritageInterface^ast := SuiteHeritageInterface^ast;
--   if HeritageInterface^tds.knows(identificateur_type^txt) then
--     o := HeritageInterface^tds.get(identificateur_type^txt);
--     d := o.get();
--     match d
--     with Interface then
--       if InstanceGenericite^ast = nil then
--         SuiteHeritageInterface^ast.add(HeritageInterface^factory.createGenericType(d));
--       else
--         SuiteHeritageInterface^ast.add(HeritageInterface^factory.createGenericType(d,InstanceGenericite^ast));
--       end
--        HeritageInterface^ast := SuiteHeritageInterface^ast;
--     else
--       error(TYPE_not_an_interface, identificateur_type^txt);
--     end
--   else
--     error(TYPE_unknown,identificateur_type^txt);
--   end
-- end
-- }

-- #inh{ --Hh
-- do
--     --InstanceGenericite^support := HeritageInterface^ast;
-- end
-- }
#inh{
local
  listInterfaces : LinkedList<String>;
do
  if(HeritageInterface^tdsInterfaces.contains(identificateur_type^txt)) then
    listInterfaces := new LinkedList<String>();
    listInterfaces.add(identificateur_type^txt);
    SuiteHeritageInterface^listInterfacesHeritage := listInterfaces;
  else 
    error(INTERFACE_unknown_ident, identificateur_type^txt);
  end
end
}

#ast{
local
  o : Optional<Declaration>;
  d : Declaration;
do
  if (HeritageInterface^tdsInterfaces.knows(identificateur_type^txt)) then
    o := HeritageInterface^tdsInterfaces.get(identificateur_type^txt);
    d := o.get();
    match d 
      with Interface then SuiteHeritageInterface^ast.addFirst(d);
    else
      error(HERITAGE_not_interface, identificateur_type^txt);
    end
  else
    error(HERITAGE_doesnt_exist, identificateur_type^txt);
  end
  HeritageInterface^ast := SuiteHeritageInterface^ast;
end
}


HeritageInterface -> #ast;
#ast{
do
  HeritageInterface^ast := new LinkedList<Interface>();
end
}

--virgule identificateur_type InstanceGenericite [...]
SuiteHeritageInterface -> virgule identificateur_type #inh SuiteHeritageInterface #ast;
-- #ast{
-- local
--   o : Optional<Declaration>;
--   d : Declaration;
-- do
--   if SuiteHeritageInterface^tds.knows(identificateur_type^txt) then
--     if SuiteHeritageInterface^tds.contains(identificateur_type^txt) then
--       error(HERITAGE_already_defined,identificateur_type^txt);
--     else
--       o := SuiteHeritageInterface^tds.get(identificateur_type^txt);
--       d := o.get();
--       match d
--       with Interface then
--         if InstanceGenericite^ast = nil then
--           SuiteHeritageInterface1^ast.add(SuiteHeritageInterface^factory.createGenericType(d));
--         else
--           SuiteHeritageInterface1^ast.add(SuiteHeritageInterface^factory.createGenericType(d,InstanceGenericite^ast));
--         end
--       else
--         error(TYPE_not_an_interface,identificateur_type^txt);
--       end
--     end
--     SuiteHeritageInterface^ast := SuiteHeritageInterface1^ast;  --Hh
--   else
--     error(TYPE_unknown,identificateur_type^txt);
--   end
-- end
-- }

#inh {
do
  if(SuiteHeritageInterface^tdsInterfaces.contains(identificateur_type^txt)) then
    SuiteHeritageInterface^listInterfacesHeritage.add(identificateur_type^txt);
    SuiteHeritageInterface1^listInterfacesHeritage := SuiteHeritageInterface^listInterfacesHeritage;
  else
    error(HERITAGE_doesnt_exist,identificateur_type^txt);
  end
end
}

#ast{
local
  o : Optional<Declaration>;
  d : Declaration;
do
  SuiteHeritageInterface^ast := SuiteHeritageInterface1^ast;
  if(SuiteHeritageInterface^tdsInterfaces.knows(identificateur_type^txt)) then
    o := SuiteHeritageInterface^tdsInterfaces.get(identificateur_type^txt);
    d := o.get();
    match d
      with Interface then SuiteHeritageInterface^ast.addFirst(d); 
    else
      error(HERITAGE_not_interface, identificateur_type^txt);
    end
  else
    error(HERITAGE_dont_exist, identificateur_type^txt);
  end
end
}

SuiteHeritageInterface -> #ast;
#ast{
do
  SuiteHeritageInterface^ast := new LinkedList<Interface>();
end
}


ElementsInterface -> ElementInterface #register ElementsInterface #ast;
#register {
do
  ElementsInterface^tds.register(ElementInterface^ast);
end
}

#ast{
do
  ElementsInterface1^ast.addFirst(ElementInterface^ast);
  ElementsInterface^ast := ElementsInterface1^ast;
end
}

ElementsInterface -> #ast;
#ast{
do
  ElementsInterface^ast := new LinkedList<ElementInterface>();
end
}

ElementInterface -> final statique Type identificateur affectation #attribut Expression point_virgule #ast;
#attribut{
do
  Expression^tds := new SymbolTable();
  Expression^droiteAffectation := true;
end
}

#ast{
local
  finalsf : FinalStaticField;
do
  if (ElementInterface^tds.knows(identificateur^txt)) then
    error(FINALSTATICFIELD_ident_already_defined);
  else
    finalsf := ElementInterface^factory.createFinalStaticField(identificateur^txt, ElementInterface^interfaceCourrante, Type^ast, Expression^ast);
    ElementInterface^ast := finalsf;
    ElementInterface^tdsAttributs.register(finalsf);
  end
end
}

ElementInterface -> Signature point_virgule #ast;
#ast{
do
  ElementInterface^ast := Signature^ast;
  ElementInterface^tdsFunctions.registerSign(Signature^ast,ElementInterface^interfaceCourrante);
end
}


Signature -> vide identificateur parenthese_ouvrante #tds Parametres parenthese_fermante #ast;
#tds{
do
  Parametres^tdsParametres := new SymbolTable();
end
}

#ast{
do
  if(Signature^tds.knows(identificateur^txt)) then
    error(SIGNATURE_ident_already_defined);
  else
    Signature^ast := Signature^factory.createSignature(identificateur^txt,Parametres^ast, Signature^interfaceCourrante);
  end
end
}  
 
Signature -> Type identificateur parenthese_ouvrante #tds Parametres parenthese_fermante #ast;
#tds{
do
  Parametres^tdsParametres := new SymbolTable();
end
}

#ast{
do
  if(Signature^tds.knows(identificateur^txt)) then
    error(SIGNATURE_ident_already_defined);
  else
    Signature^ast := Signature^factory.createSignature(identificateur^txt,Type^ast,Parametres^ast, Signature^interfaceCourrante );
  end
end
}  



Parametres -> #ast ;
#ast {
do
   Parametres^ast := new LinkedList<Parametre>();
end
}

Parametres -> Parametre #register SuiteParametres #ast ;
#register {
do
  Parametres^tdsParametres.register(Parametre^ast);
end
}

#ast {
do 
   SuiteParametres^ast.addFirst(Parametre^ast);
   Parametres^ast := SuiteParametres^ast;  
end 
}


SuiteParametres -> #ast;
#ast {
do
   SuiteParametres^ast := new LinkedList<Parametre>();
end
}

SuiteParametres -> virgule Parametre #register SuiteParametres #ast;
#register {
do
  SuiteParametres^tdsParametres.register(Parametre^ast);
end
}


#ast {
do
  SuiteParametres1^ast.addFirst(Parametre^ast); 
   SuiteParametres^ast := SuiteParametres1^ast; 
end
}

Parametre -> Type identificateur #ast;
#ast {
do
  if Parametre^tds.contains(identificateur^txt) then
    error(PARAMETRE_already_defined, identificateur^txt);
  else
    Parametre^ast := Parametre^factory.createParametre(identificateur^txt, Type^ast);
  end
end
}

--------------------------------------
--l 348 > 441 (CLASSES)
--------------------------------------


Classes -> Classe #list Classes #ast;
#ast {
do
  Classes1^ast.addFirst(Classe^ast);
  Classes^ast := Classes1^ast;
end
}

#list {
do
  if(Classes^tdsClasses.contains(Classe^ast.getName())) then
    error(CLASSE_already_defined,Classe^ast.getName());
  else
    Classes^tdsClasses.register(Classe^ast);
  end
end
}

Classes -> #ast;
#ast {
do
  Classes^ast := new LinkedList<Classe>();
end
}

--Classe -> classe  identificateur_type Genericite HeritageClasse ImplantationInterface accolade_ouvrante ElementsClasse accolade_fermante #ast;
Classe -> classe  identificateur_type HeritageClasse #inhlist ImplantationInterface accolade_ouvrante #inh ElementsClasse accolade_fermante #ast;
#inhlist {
do
  ImplantationInterface^listInterfacesHeritage := new LinkedList<String>();
end
}
#inh {
do
  ElementsClasse^tds := new SymbolTable();
  ElementsClasse^classeCourrante := identificateur_type^txt;
end
}



#ast {
do
  Classe^ast := Classe^factory.createClasse(identificateur_type^txt,HeritageClasse^ast,ImplantationInterface^ast,ElementsClasse^ast);
end
}

--HeritageClasse -> extension identificateur_type #inh InstanceGenericite #ast ;
HeritageClasse -> extension identificateur_type #ast ;
--#inh {
--local
--  f : Optional<Declaration>;
--  d : Declaration;
--do
--   if HeritageClasse^tds.knows(identificateur_type^txt) then
--     f := HeritageClasse^tds.get(identificateur_type^txt);
--     d := f.get();
--     match d
--     with GenericType then InstanceGenericite^support := HeritageClasse^factory.createGenericTypeUse(d);
--     end
--   else
--     error(TYPE_unknown,identificateur_type^txt);
--   end
-- end
-- }

#ast {
local
  o : Optional<Declaration>;
  d : Declaration;
do
  if(HeritageClasse^tdsClasses.knows(identificateur_type^txt)) then
  o := HeritageClasse^tdsClasses.get(identificateur_type^txt);
  d := o.get();
  match d
    with Classe then 
      HeritageClasse^ast := new LinkedList<Classe>(); --Il ne peut y avoir qu'un seul heritageClasse -> optionnal ?!
      HeritageClasse^ast.add(d);
    else
      error (HERITAGE_not_classe,identificateur_type^txt);
    end
  else
    error(HERITAGE_doesnt_exist);
  end
end
}


HeritageClasse -> #ast;
#ast {
do
  HeritageClasse^ast := new LinkedList<Classe>();
end
}


-- ImplantationInterface -> implantation identificateur_type InstanceGenericite SuiteHeritageInterface #ast; 
ImplantationInterface -> implantation identificateur_type #inh SuiteHeritageInterface #ast;
#inh{
local
  listInterfaces : LinkedList<String>;
do
  if(ImplantationInterface^tdsInterfaces.contains(identificateur_type^txt)) then
    listInterfaces := new LinkedList<String>();
    listInterfaces.add(identificateur_type^txt);
    SuiteHeritageInterface^listInterfacesHeritage := listInterfaces;
  else 
    error(INTERFACE_unknown_ident, identificateur_type^txt);
  end
end
}

#ast{
local
  o : Optional<Declaration>;
  d : Declaration;
do
  if(ImplantationInterface^tdsInterfaces.knows(identificateur_type^txt)) then
    o := ImplantationInterface^tdsInterfaces.get(identificateur_type^txt);
    d := o.get();
    match d
      with Interface then SuiteHeritageInterface^ast.addFirst(d); 
    else
      error(HERITAGE_not_interface, identificateur_type^txt);
    end
  else
    error(HERITAGE_dont_exist, identificateur_type^txt);
  end
    ImplantationInterface^ast := SuiteHeritageInterface^ast;
end
}


ImplantationInterface -> #ast;
#ast {
do
  ImplantationInterface^ast := new LinkedList<Interface>();
end
}

--------------------------------------
--l 602 > 714 (ELMTS CLASSES)
--------------------------------------

ElementsClasse -> DroitAcces #inh ElementClasse ElementsClasse #ast ;
#inh {
do
  ElementClasse^droit := DroitAcces^acces;
end
}
-- #register {
-- do
--   ElementsClasse^tds.register(ElementClasse^ast);
-- end
-- }

#ast {
do
  ElementsClasse1^ast.addFirst(ElementClasse^ast);
  ElementsClasse^ast := ElementsClasse1^ast;
end
}
  
ElementsClasse -> #ast ;
#ast {
do
   ElementsClasse^ast := new LinkedList<ElementClasse>();
end
}

DroitAcces -> public #ast ;
#ast {
do
   DroitAcces^acces := DroitAcces.Public;
end
}

DroitAcces -> protege #ast ;
#ast {
do
   DroitAcces^acces := DroitAcces.Protected;
end
}
 
DroitAcces -> prive #ast ;  
#ast {
do
   DroitAcces^acces := DroitAcces.Private;
end
}
 

ElementClasse -> statique #inh AttributOuMethode #ast;
#inh {
do
  AttributOuMethode^static := true;
end
}

#ast {
do
  ElementClasse^ast := AttributOuMethode^ast;
end
}
 

ElementClasse -> #inh AttributOuMethode #ast;
#inh {
do
  AttributOuMethode^static := false;
end
}
#ast {
do
  ElementClasse^ast := AttributOuMethode^ast;
end
}
 

ElementClasse -> Constructeur #ast;  
#ast {
do
  ElementClasse^ast := Constructeur^ast;
end
}
    

AttributOuMethode -> Type identificateur #inh SuiteAttributOuMethode #ast;
#inh {
do
  SuiteAttributOuMethode^ident := identificateur^txt;
  SuiteAttributOuMethode^type := Type^ast;
end
}
#ast {
do
  -- if AttributOuMethode^tds.knows(identificateur^txt) then --(contains ou knows je sais plus ?)
  --   error(IDENT_already_used, identificateur^txt);
  -- else
  --   AttributOuMethode^ast := SuiteAttributOuMethode^ast;
  --   AttributOuMethode^tds.register(SuiteAttributOuMethode^ast);
  -- end
  AttributOuMethode^ast := SuiteAttributOuMethode^ast;
end
}
 

AttributOuMethode -> vide identificateur parenthese_ouvrante #inh Parametres parenthese_fermante #inhBloc Bloc #ast ;
global
	tdsBlocParam : SymbolTable;
#inh {
do
  tdsBlocParam := new SymbolTable();
  Parametres^tdsParametres := tdsBlocParam;
end
}
#inhBloc {
do 
	Bloc^tds := tdsBlocParam; --Pb: le bloc ne connait pas les parametres !! => Parametres^support ?
end
}
#ast {
local
  met : Methode;
do
  met := AttributOuMethode^factory.createMethode(identificateur^txt,AttributOuMethode^classeCourrante,AttributOuMethode^droit,Parametres^ast,Bloc^ast,AttributOuMethode^static, AtomicType.VoidType);
  if AttributOuMethode^tdsFunctions.containFun(met) then --(contains ou knows je sais plus ?)
    error(IDENT_already_used, identificateur^txt);
  else
    AttributOuMethode^ast := met;
    AttributOuMethode^tdsFunctions.registerFun(met);
  end
end
}
 

SuiteAttributOuMethode -> point_virgule #ast;
#ast {
local
  att : Attribut;
do
  if(SuiteAttributOuMethode^tdsAttributs.knows(SuiteAttributOuMethode^ident)) then
    error(IDENT_already_used, SuiteAttributOuMethode^ident);
  else
    att := SuiteAttributOuMethode^factory.createAttribut(SuiteAttributOuMethode^ident, SuiteAttributOuMethode^classeCourrante, SuiteAttributOuMethode^type, SuiteAttributOuMethode^droit, SuiteAttributOuMethode^static);
    SuiteAttributOuMethode^ast := att;
    SuiteAttributOuMethode^tdsAttributs.register(att);
  end
end
}
 

SuiteAttributOuMethode -> parenthese_ouvrante #inh Parametres parenthese_fermante #inhBloc Bloc #ast ;

global
	tdsBlocParam : SymbolTable;
#inh {
do
  tdsBlocParam := new SymbolTable();
  Parametres^tdsParametres := tdsBlocParam;
end
}
#inhBloc {
do 
	Bloc^tds := tdsBlocParam; --Pb: le bloc ne connait pas les parametres !! => Parametres^support ?
end
}
#ast {
local
  met : Methode;
do
  met := SuiteAttributOuMethode^factory.createMethode(SuiteAttributOuMethode^ident, SuiteAttributOuMethode^classeCourrante, SuiteAttributOuMethode^droit,  Parametres^ast,Bloc^ast,SuiteAttributOuMethode^static, SuiteAttributOuMethode^type);
  if(SuiteAttributOuMethode^tdsFunctions.containFun(met)) then
    error(IDENT_already_used, SuiteAttributOuMethode^ident);
  else
    SuiteAttributOuMethode^ast := met;
    SuiteAttributOuMethode^tdsFunctions.registerFun(met);
  end
end
}

Constructeur -> identificateur_type parenthese_ouvrante #inh Parametres parenthese_fermante #inhBloc Bloc #ast ;
global
	tdsBlocParam : SymbolTable;
#inh {
do
  tdsBlocParam := new SymbolTable();
  Parametres^tdsParametres := tdsBlocParam;
end
}
#inhBloc {
do 
	Bloc^tds := tdsBlocParam; --Pb: le bloc ne connait pas les parametres !! => Parametres^support ?
end
}
#ast {
local
  cons : Constructeur;
do
  if(Constructeur^classeCourrante.equals(identificateur_type^txt)) then
    cons := Constructeur^factory.createConstructeur(identificateur_type^txt, Constructeur^classeCourrante, Constructeur^droit, Parametres^ast, Bloc^ast);
    if(Constructeur^tdsFunctions.containCons(cons)) then
      error(CONSTRUCTOR_signature_already_exists,identificateur_type^txt);
    else
      Constructeur^ast := cons;
      Constructeur^tdsFunctions.registerConstructeur(cons);
    end
  else
    error(CONSTRUCTOR_name_missmatch, identificateur_type^txt);
  end
end
}

--------------------------------------
-- l 444 > 460  Principale
--------------------------------------

Principale -> public classe identificateur_type accolade_ouvrante MethodePrincipale accolade_fermante #ast;
#ast {
do
   if (Principale^tdsClasses.contains(identificateur_type^txt)) then
      error(TYPE_already_defined, identificateur_type^txt);
   else
      Principale^ast := Principale^factory.createClassePrincipale(identificateur_type^txt,MethodePrincipale^ast);
   end
end
}

MethodePrincipale -> public statique vide principale parenthese_ouvrante type_String crochet_ouvrant crochet_fermant identificateur parenthese_fermante Bloc #ast;
#ast {
do
   MethodePrincipale^ast := Bloc^ast;
end
}
--------------------------------------
-- l 759  Bloc
--------------------------------------

Bloc -> accolade_ouvrante Instructions accolade_fermante #ast;
#ast {
do
 Bloc^ast := Bloc^factory.createBlock(Instructions^list);
end
}

--------------------------------------
--l 664 > 702 (TYPES)
--------------------------------------

Type -> TypeAtomique #inhArray SuiteTypeAtomique #ast;
#inhArray {
do
  SuiteTypeAtomique^innerArray := TypeAtomique^ast;
end
}

#ast {
do
  Type^ast := TypeAtomique^ast;
end
}




TypeAtomique -> type_bool #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createBooleanType();  
end
}

TypeAtomique -> type_int  #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createIntegerType();  
end
}
 
TypeAtomique -> type_char #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createCharType();  
end
}

TypeAtomique -> type_String #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createStringType();  
end
}

--TypeAtomique -> identificateur_type InstanceGenericite 
TypeAtomique -> identificateur_type #ast;
#ast {
local
	o : Optional<Declaration>;
	d : Declaration;
do
	if(TypeAtomique^tdsClasses.contains(identificateur_type^txt)) then
		o := TypeAtomique^tdsClasses.get(identificateur_type^txt);
		d := o.get();
		match d 
			with Classe then
				TypeAtomique^ast := TypeAtomique^factory.createClasseType(d);
      end
	else
    if (TypeAtomique^tdsInterfaces.contains(identificateur_type^txt)) then
		o := TypeAtomique^tdsInterfaces.get(identificateur_type^txt);
		d := o.get();
		match d
			with Interface then
				TypeAtomique^ast := TypeAtomique^factory.createInterfaceType(d);
      end
	  else --LiaisonTardive ...

	  	  TypeAtomique^ast := TypeAtomique^factory.createUndeclaredType(identificateur_type^txt);
	  	  error(LiaisonTardive_,identificateur_type^txt);
		  --error(TYPE_unknown,identificateur_type^txt);
    end
	end
end
}

SuiteTypeAtomique -> crochet_ouvrant crochet_fermant #inhArray SuiteTypeAtomique #ast;
#inhArray {
do
  SuiteTypeAtomique1^innerArray := SuiteTypeAtomique^factory.createArrayType(SuiteTypeAtomique^innerArray);
end
}

#ast {
do
  SuiteTypeAtomique^ast := SuiteTypeAtomique1^ast;
end
}

SuiteTypeAtomique -> #ast;
#ast {
do
  SuiteTypeAtomique^ast := SuiteTypeAtomique^innerArray;
end
}


----------------------------------------------------------------------------------------------------
--
-- Classes, Blocs [...]
--
----------------------------------------------------------------------------------------------------

---------------------------
--l463 > 519 Genericite
---------------------------
-- Genericite -> inferieur ParametresGenericite superieur #ast ;
-- #ast {
-- do
--    Genericite^ast := ParametresGenericite^ast;
-- end
-- }

-- Genericite -> #ast;
-- #ast {
-- do
--   Genericite^ast := nil;
-- end
-- }

-- ParametresGenericite -> ParametreGenericite SuiteParametresGenericite #ast;
-- #ast {
-- do
--   SuiteParametresGenericite^ast.addFirst(ParametreGenericite^ast);
--   ParametresGenericite^ast := SuiteParametresGenericite^ast;
--   ParametreGenericite^tds.register(ParametreGenericite^ast);

-- end
-- }

-- SuiteParametresGenericite -> virgule ParametreGenericite SuiteParametresGenericite #ast;
-- #ast {
-- do
--   SuiteParametresGenericite1^ast.addFirst(ParametreGenericite^ast);
--   SuiteParametresGenericite^ast := SuiteParametresGenericite1^ast;
--   SuiteParametresGenericite^tds.register(ParametreGenericite^ast);
-- end
-- }
-- SuiteParametresGenericite -> #ast;
-- #ast {
-- do
--    SuiteParametresGenericite^ast := new LinkedList<ParametreGenericite>();
-- end
-- }

-- ParametreGenericite -> identificateur_type HeritageGenericite #ast ; 
-- #ast {
-- do
--   if ParametreGenericite^tds.contains(identificateur_type^txt) then
--     error(GENERICITE_already_defined, identificateur_type^txt);
--   else
--     ParametreGenericite^ast := ParametreGenericite^factory.createGenericParameter(identificateur_type^txt, HeritageGenericite^ast);
--   end
-- end
-- } 
 
-- ParametreGenericite -> choix HeritageGenericite #ast ;  
-- #ast {
-- do
--   ParametreGenericite^ast := ParametreGenericite^factory.createGenericParameter(HeritageGenericite^ast);
-- end
-- }

---------------------------------
--l521 > 564 - HeritageGenericite
---------------------------------

-- TODO <? extends T Suite> = on crée un parametre generique qui recupere les trucs de suiteHeritageGenericite
-- Avant HeritageGenericite -> extension identificateur_type SuiteHeritageGenericite #ast;
-- HeritageGenericite -> extension identificateur_type InstanceGenericite SuiteHeritageGenericite #ast;
-- #ast {
-- local
--     f : Optional<Declaration>;
--     d : Declaration;
-- do
--     if HeritageGenericite^tds.knows(identificateur_type^txt) then
--         f := HeritageGenericite^tds.get(identificateur_type^txt);
--         d := f.get();
--         if (InstanceGenericite^ast = nil) then
--             match d
--             with Objet then
--                 SuiteHeritageGenericite^ast.addFirst(d.getType());
--                 HeritageGenericite^ast := SuiteHeritageGenericite^ast;
--             else
--                 error(DECL_not_an_object, identificateur_type^txt);
--             end
--         else
--             match d
--             with Objet then
--                 SuiteHeritageGenericite^ast.addFirst(HeritageGenericite^factory.createTypeGenerique(d, InstanceGenericite^ast));
--                 HeritageGenericite^ast := SuiteHeritageGenericite^ast;
--             else
--                 error(DECL_not_an_object, identificateur_type^txt);
--             end
--         end
--     else
--         error(Undefined_ident,identificateur_type^txt);
--     end
-- end
-- }

-- TO DO : <?> = on crée juste un parametre generique quelconque --Hh -> pas sur sur... (Vivian ?)
-- HeritageGenericite -> #ast;
-- #ast {
-- do
--   HeritageGenericite^ast := nil;
-- end
-- }

-- TODO <? extends T & Interface1 (& Interface2 ...) >
-- Avant: SuiteHeritageGenericite -> adresse identificateur_type SuiteHeritageGenericite #ast; ???
-- SuiteHeritageGenericite -> adresse identificateur_type InstanceGenericite SuiteHeritageGenericite #ast;
-- #ast {
-- local
--     f : Optional<Declaration>;
--     d : Declaration;
-- do
--     if SuiteHeritageGenericite^tds.knows(identificateur_type^txt) then
--         f := SuiteHeritageGenericite^tds.get(identificateur_type^txt);
--         d := f.get();
--         if (InstanceGenericite = nil) then
--             match d
--             with Objet then 
--                 SuiteHeritageGenericite1^ast.addFirst(d.getType());
--                 SuiteHeritageGenericite^ast := SuiteHeritageGenericite1^ast;
--             else
--                 error(DECL_not_an_object, identificateur_type^txt);
--             end
--         else
--             match d
--             with Objet then 
--                 SuiteHeritageGenericite1^ast.addFirst(SuiteHeritageGenericite^factory.createTypeGenerique(d, InstanceGenericite^ast));
--                 SuiteHeritageGenericite^ast := SuiteHeritageGenericite1^ast;
--             else
--                 error(DECL_not_an_object, identificateur_type^txt);
--             end
--         end
--     else
--         error(Undefined_ident, identificateur_type^txt);
--     end
-- end
-- }

-- -- TODO <? extends T >
-- SuiteHeritageGenericite -> #ast;
-- #ast {
-- do
--   SuiteHeritageGenericite^ast := new LinkedList<Objet>();
-- end
-- }


---------------------------------
--l567 > 599 - InstanceGenericite
---------------------------------

-- InstanceGenericite -> #ast;
-- #ast{
-- do
--   InstanceGenericite^ast := nil;
-- end
-- }

-- InstanceGenericite -> inferieur ArgumentsGenericite superieur #ast;
-- #ast{
-- do
--   InstanceGenericite^ast := ArgumentsGenericite^ast;
-- end
-- }

-- ArgumentsGenericite -> ArgumentGenericite SuiteArgumentsGenericite #ast;
-- #ast {
-- do
-- 	SuiteArgumentsGenericite^ast.addFirst(ArgumentGenericite^ast);
-- 	ArgumentsGenericite^ast := SuiteArgumentsGenericite^ast;
-- end
-- }

-- SuiteArgumentsGenericite -> virgule ArgumentGenericite SuiteArgumentsGenericite #ast;
-- #ast {
-- do
-- 	SuiteArgumentsGenericite1^ast.addFirst(ArgumentGenericite^ast);
-- 	SuiteArgumentsGenericite^ast := SuiteArgumentsGenericite1^ast;
-- end
-- }

-- SuiteArgumentsGenericite -> #ast;
-- #ast {
-- do
--    SuiteArgumentsGenericite^ast := new LinkedList<Type>();
-- end
-- }

-- ArgumentGenericite -> identificateur_type InstanceGenericite #ast;
-- #ast {
-- local
-- 	o : Optional<Declaration>;
-- 	d : Declaration;
-- do
-- 	if ArgumentGenericite^tds.knows(identificateur_type^txt) then
-- 		o := ArgumentGenericite^tds.get(identificateur_type^txt);
-- 		d := o.get();
-- 		match d
-- 		--Autre chose que Objet ? Type ?    --Hh j'ai ajouté extends Type pour les ArgumentsGénéricité
--                                         -- cf erreur error: incompatible types: ArgumentGenericite cannot be converted to Type
--                                         -- this.att_ast=this.att_factory.createArgumentGenericite(((Objet)loc_d));
-- 		with Objet then
-- 			if InstanceGenericite^ast = nil then
-- 				ArgumentGenericite^ast := ArgumentGenericite^factory.createArgumentGenericite(d);
-- 			else
-- 				ArgumentGenericite^ast := ArgumentGenericite^factory.createArgumentGenericite(d,InstanceGenericite^ast);
-- 			end
-- 		end
-- 	end
-- end
-- }


--TO DO
--ArgumentGenericite -> type_String ;




--------------------------------------
--l 804 > end (Tout après Expression)
--------------------------------------
-- [...]

Instructions -> #ast;
#ast {
do
   Instructions^list := new LinkedList<Instruction>();
end
}

Instructions -> Instruction Instructions #ast ;
#ast {
do
    Instructions1^list.addFirst(Instruction^ast);
    Instructions^list := Instructions1^list;
end
}

Instruction -> Type identificateur affectation #inh Expression point_virgule #ast;
#inh{
do
	Expression^droiteAffectation := true;
end
}

#ast {
local
  d : VariableDeclaration;
do
    if Instruction^tds.contains(identificateur^txt) then
    	error(IDENT_already_used);
    else
    	match Type^ast 
    		with ClasseTypeImpl then
    			d := Instruction^factory.createClasseDeclaration(identificateur^txt,Type^ast,Expression^ast);
    			Instruction^tds.register(d);
    			Instruction^ast := d ;
    		with UndeclaredTypeImpl then
    			d := Instruction^factory.createClasseDeclaration(identificateur^txt,Type^ast,Expression^ast);
    			Instruction^tds.register(d);
    			Instruction^ast := d ;
    		else
    			d := Instruction^factory.createVariableDeclaration(identificateur^txt,Type^ast,Expression^ast);
    		    Instruction^tds.register(d);
    			Instruction^ast := d ;
    		end
    end

end
}


Instruction -> #inh Expression point_virgule #ast;
#inh{
do
	Expression^droiteAffectation := false;
end
}
#ast{
do
  match Expression^ast 
  with Instruction then
    Instruction^ast := Expression^ast;
  end
end
}


Instruction -> si parenthese_ouvrante #inhExpr Expression parenthese_fermante #inhB Bloc #inh SuiteConditionnelle #ast;
#inhExpr{
do
	Expression^droiteAffectation := false;
end	
}
#inhB {
do
        Bloc^tds := new SymbolTable(Instruction^tds);
end
}

#inh {
do
    SuiteConditionnelle^condition := Expression^ast;
    SuiteConditionnelle^alors := Bloc^ast;
end
}

#ast {
do
   Instruction^ast := SuiteConditionnelle^ast;
   
end
}

SuiteConditionnelle -> #ast;
#ast {
do
    SuiteConditionnelle^ast := SuiteConditionnelle^factory.createConditional(SuiteConditionnelle^condition, SuiteConditionnelle^alors);
end
}

SuiteConditionnelle ->sinon #inh Bloc #ast;
#inh {
do
        Bloc^tds := new SymbolTable(SuiteConditionnelle^tds);   
end
}
#ast {
do
    SuiteConditionnelle^ast := SuiteConditionnelle^factory.createConditional(SuiteConditionnelle^condition, SuiteConditionnelle^alors,Bloc^ast);
end
}



Instruction -> tant_que parenthese_ouvrante #inhExpr Expression parenthese_fermante #inh Bloc #ast ;
#inhExpr{
do
	Expression^droiteAffectation := false;
end
}
#inh {
do
   Bloc^tds := new SymbolTable(Instruction^tds);
end
}

#ast {
do
	Instruction^ast := Instruction^factory.createRepetition(Expression^ast,Bloc^ast);
end
}




Instruction -> afficher #inhExpr Expression point_virgule #ast ;
#inhExpr{
do
	Expression^droiteAffectation := false;
end
}
#ast {
do
   Instruction^ast := Instruction^factory.createPrinter(Expression^ast);
end
}



Instruction -> retour #inhExpr Expression point_virgule #ast ;
#inhExpr{
do
	Expression^droiteAffectation := false;
end
}
#ast {
do
   Instruction^ast := Instruction^factory.createReturn(Expression^ast); -- (classe TODO)
end
}



Expression -> Affectation #inh SuiteAffectation #ast;
#inh {
do
   SuiteAffectation^gauche := Affectation^ast ;
end 
}

#ast {
do
    Expression^ast := SuiteAffectation^ast;
end 
}

Affectation -> Condition #inh SuiteCondition #ast;
#inh {
do
   SuiteCondition^gauche := Condition^ast ;
end 
}
#ast {
do
    Affectation^ast := SuiteCondition^ast;
end 
}


SuiteAffectation -> affectation #inh Expression #ast;
#ast {
do
	SuiteAffectation^ast := SuiteAffectation^factory.createAssignment(SuiteAffectation^gauche, Expression^ast);
end
}
#inh {
do
	Expression^droiteAffectation := true;
end
}


SuiteAffectation ->  #ast;
#ast {
do
	SuiteAffectation^ast := SuiteAffectation^gauche;
end
}

SuiteCondition -> Comparatif Condition #ast ;
#ast {
do
  SuiteCondition^ast :=  SuiteCondition^factory.createBinaryExpression(
  								SuiteCondition^gauche, Comparatif^bin_op, Condition^ast);
end 
}

SuiteCondition -> #ast ;
#ast {
do
   SuiteCondition^ast := SuiteCondition^gauche;
end 
}

Comparatif -> egalite #texte;  
#texte {  
do  
   Comparatif^bin_op := BinaryOperator.Equals;   
end  
}

Comparatif -> different #texte;  
#texte {  
do  
   Comparatif^bin_op := BinaryOperator.Different;   
end  
}
  
Comparatif -> inferieur #texte;  
#texte {  
do  
   Comparatif^bin_op := BinaryOperator.Lesser;   
end  
}
  
Comparatif -> inferieur_egal #texte;  
#texte {  
do  
   Comparatif^bin_op := BinaryOperator.LesserOrEqual;   
end  
}
  
Comparatif -> superieur #texte;  
#texte {   
do  
   Comparatif^bin_op := BinaryOperator.Greater;    
end  
}
   
Comparatif -> superieur_egal #texte;  
#texte {   
do  
   Comparatif^bin_op := BinaryOperator.GreaterOrEqual;    
end  
}
 


Condition -> Terme #ast_inh SuiteTerme #ast_syn ;
#ast_inh {
do 
   SuiteTerme^gauche := Terme^ast; 
end 
}

#ast_syn {
do
   Condition^ast := SuiteTerme^ast; 
end
}

SuiteTerme -> Additif Terme #ast_inh SuiteTerme #ast_syn ;  
#ast_inh {
do
   SuiteTerme1^gauche := SuiteTerme^factory.createBinaryExpression(
      SuiteTerme^gauche,  
      Additif^bin_op,  
      Terme^ast);  
end 
}

#ast_syn {
do 
   SuiteTerme^ast := SuiteTerme1^ast; 
end 
}

SuiteTerme -> #ast ;
#ast {
do
   SuiteTerme^ast := SuiteTerme^gauche;
end
}


Additif -> soustraction #ast;  
#ast {  
do  
   Additif^bin_op := BinaryOperator.Substract;   
end  
}
   
Additif -> ou #ast;  
#ast {  
do  
   Additif^bin_op := BinaryOperator.Or;   
end  
}

Additif -> addition #ast;  
#ast {  
do  
   Additif^bin_op := BinaryOperator.Add;   
end  
}

Terme -> Facteur #ast_inh SuiteFacteur #ast_syn ;
#ast_inh {
do 
   SuiteFacteur^gauche := Facteur^ast; 
end 
}

#ast_syn {
do
   Terme^ast := SuiteFacteur^ast; 
end
}

SuiteFacteur -> Multiplicatif Facteur #ast_inh SuiteFacteur #ast_syn ;  
#ast_inh {
do 
   SuiteFacteur1^gauche := SuiteFacteur^factory.createBinaryExpression(
      SuiteFacteur^gauche,  
      Multiplicatif^bin_op,  
      Facteur^ast);  
end 
}

#ast_syn {
do 
   SuiteFacteur^ast := SuiteFacteur1^ast; 
end 
}
 
SuiteFacteur -> #ast;  
#ast {
do
   SuiteFacteur^ast := SuiteFacteur^gauche;
end
}

Multiplicatif -> multiplication #ast; 
#ast { 
do 
   Multiplicatif^bin_op := BinaryOperator.Multiply;  
end 
}

Multiplicatif -> division #ast; 
#ast { 
do 
   Multiplicatif^bin_op := BinaryOperator.Divide;  
end 
}
 
Multiplicatif -> modulo #ast; 
#ast {  
do 
   Multiplicatif^bin_op := BinaryOperator.Modulo;   
end 
}
  
Multiplicatif -> et #ast; 
#ast {  
do 
   Multiplicatif^bin_op := BinaryOperator.And;   
end 
}
  


Facteur -> accolade_ouvrante Expressions accolade_fermante #ast ;
#ast {
do
   Facteur^ast := Facteur^factory.createSequence( Expressions^ast );
end
}

Expressions -> #inhExpr Expression SuiteExpressions #ast ;
#inhExpr{
do
	Expression^droiteAffectation := false;
end
}
#ast {
do 
   SuiteExpressions^ast.addFirst(Expression^ast); 
   Expressions^ast := SuiteExpressions^ast; 
end 
}

SuiteExpressions -> virgule #inhExpr Expression SuiteExpressions #ast ;
#inhExpr{
do
	Expression^droiteAffectation := false;
end
}
#ast {
do 
   SuiteExpressions1^ast.addFirst(Expression^ast); 
   SuiteExpressions^ast := SuiteExpressions1^ast; 
end 
}

SuiteExpressions -> #ast ;
#ast {
do
   SuiteExpressions^ast := new LinkedList<Expression>();
end
}

Facteur -> soustraction Facteur #ast ;  
#ast { 
do  
   Facteur^ast := Facteur ^factory.createUnaryExpression(UnaryOperator.Opposite,Facteur1^ast);  
end  
}
 
Facteur -> negation Facteur #ast ;  
#ast { 
do  
   Facteur^ast := Facteur ^factory.createUnaryExpression(UnaryOperator.Negate,Facteur1^ast);  
end  
}

Facteur -> nouveau Type #inh SuiteNouveau #ast ; 
#inh {
do 
   SuiteNouveau^type := Type^ast; 
end 
}
#ast {
do 
   Facteur^ast := SuiteNouveau^ast; 
end 
}

SuiteNouveau -> crochet_ouvrant #inhExpr Expression crochet_fermant #ast ; 
#inhExpr{
do
	Expression^droiteAffectation := false;
end
}
#ast {
do  
   SuiteNouveau^ast := SuiteNouveau^factory.createArrayAllocation(SuiteNouveau^type,Expression^ast);  
end  
}



SuiteNouveau -> Arguments #ast ;
#ast {
do
	SuiteNouveau^ast := SuiteNouveau^factory.createObjetAllocation(SuiteNouveau^type,Arguments^ast);
end
}

Arguments -> parenthese_ouvrante parenthese_fermante #ast;
#ast {
do
	Arguments^ast := new LinkedList<Expression>();
end	
}


Arguments -> parenthese_ouvrante Expressions parenthese_fermante #ast ;
#ast {
do
	Arguments^ast := Expressions^ast;
end	
}



--pas de pointeur en Java ?!
-- SuiteNouveau -> #ast ; 
-- #ast {
-- do 
--    SuiteNouveau^ast := SuiteNouveau^factory.createPointerAllocation(SuiteNouveau^type); 
-- end 
-- }

Facteur -> Valeur #ast;
#ast {
do
   Facteur^ast := Valeur^ast  ; --Hh
end
}
 
Valeur -> entier #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createIntegerValue(entier^txt); 
end
}

Valeur -> vrai #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(true);  
end
}

Valeur -> faux #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(false);  
end
}

Valeur -> chaine #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createStringValue(chaine^txt);  
end
}

Valeur -> caractere #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createCharacterValue(caractere^txt);  
end
}



Facteur -> identificateur #inh AppelOuAcces #ast ;
#inh {
local
   o : Optional<Declaration>;
   d : Declaration;
do
   if (Facteur^tds.contains(identificateur^txt)) then
      o := Facteur^tds.get(identificateur^txt);
      d := o.get();
      match d
      with ConstantDeclaration then AppelOuAcces^support := d.getValue();
      with FinalStaticField then AppelOuAcces^support := d.getValue();
      with ClasseDeclaration then AppelOuAcces^support := Facteur^factory.createClasseUse(d);
      with VariableDeclaration then
      		if(Facteur^droiteAffectation) then
      			AppelOuAcces^support := Facteur^factory.createVariableUse(d);
      		else
      			AppelOuAcces^support := Facteur^factory.createVariableAssignment(d);
      			error(Fichtre_, d);
      		end
      with Parametre then AppelOuAcces^support := Facteur^factory.createParametreUse(d);
      end
    elseif (Facteur^tdsAttributs.contains(identificateur^txt)) then
    	o := Facteur^tdsAttributs.get(identificateur^txt);
    	d := o.get();
    	match d
    	with Attribut then
    		if (Facteur^droiteAffectation) then
    			AppelOuAcces^support := Facteur^factory.createAttributUse(d,null);
    		else 
    			AppelOuAcces^support := Facteur^factory.createAttributAssignment(d,null);
    		end
    	with FinalStaticField then AppelOuAcces^support := d.getValue();
    	else error(UNDEFINED_attribut_staticfield, identificateur^txt);
    	end
    else
      error(BLOC_undefined_ident, identificateur^txt);
   end
end
}
#ast {
do
  Facteur^ast := AppelOuAcces^ast; --Hh
end  
}



--Considere comme un appel a une constante d'une interface ?!
Facteur -> identificateur_type point identificateur #inh AppelOuAcces #ast ;
#inh {
local
	o : Optional<Declaration>;
	d : Declaration;
do
	if Facteur^tdsInterfaces.knows(identificateur_type^txt) then
		o := Facteur^tdsInterfaces.get(identificateur_type^txt);
		d := o.get();
		match d 
			with Interface then 
				if(d.hasFinalStaticField(identificateur^txt)) then
					AppelOuAcces^support := d.getFinalStaticField(identificateur^txt);
				else
					error(IDENT_unknown, identificateur^txt);
				end
		end
	else 
		error(IDENT_unknown, identificateur_type^txt);
	end
end
}

#ast {
do
	Facteur^ast := AppelOuAcces^ast;
end
}


--TODO
Facteur -> parenthese_ouvrante #inhExpr Expression parenthese_fermante #ast;
#inhExpr{
do
	Expression^droiteAffectation := false;
end
}
#ast {
do
	Facteur^ast := Expression^ast;
end
}



AppelOuAcces -> #inh Acces #ast;
#inh {
do
	Acces^support := AppelOuAcces^support;
end
}

#ast {
do
	AppelOuAcces^ast := Acces^ast;
end
}


AppelOuAcces -> #inh Appel #ast ;
#inh {
do
	Appel^support := AppelOuAcces^support;
end
}

#ast {
do
	AppelOuAcces^ast := Appel^ast;
end
}

Acces -> #ast ;
#ast { 
do  
   Acces^ast := Acces^support;  
end  
}


Acces -> crochet_ouvrant #inhExpr Expression crochet_fermant #inh Acces #ast;
#inhExpr{
do
	Expression^droiteAffectation := false;
end
}
#inh {
do
	Acces1^support := Acces^factory.createArrayAccess(Acces^support,Expression^ast);
end
}

#ast {
do
    Acces^ast := Acces1^ast; 
end
}


-- TODO --trèèèèèèèèèèèès compliquêêêêêêêêêêêêêê
Acces -> point identificateur #inh AppelOuAcces #ast;
#ast{
do
  Acces^ast := AppelOuAcces^ast;
end
}

#inh{
local
	exp : Expression;
	expAtt : Expression;

	tmpcti : Type;
	tmpc : Classe;

do
	exp := Acces^support;
	match exp
		with ClasseUseImpl then 
			if(exp.containsAttribut(identificateur^txt)) then
				expAtt := exp.getAttribut(identificateur^txt);
				match expAtt
					with ElementClasse then
						if (Acces^droiteAffectation) then --Hh
							AppelOuAcces^support := Acces^factory.createAttributUse(expAtt,exp);
						else 
							AppelOuAcces^support := Acces^factory.createAttributAssignment(expAtt,exp);
						end
				end
			elseif (exp.containsMethode(identificateur^txt)) then
				expAtt := exp.getMethode(identificateur^txt);
				match expAtt
					with Methode then
						AppelOuAcces^support := Acces^factory.createMethodeUse(expAtt,exp);
				end
			else
				error(ATTRIBUT_doesnt_exist,exp.getName(),identificateur^txt);
			end
		with AttributUseImpl then 
			tmpcti := exp.getType();
			match tmpcti
				with ClasseTypeImpl then
					tmpc := tmpcti.getClasse();
					if(tmpc.containsAttribut(identificateur^txt)) then
						expAtt := tmpc.getAttribut(identificateur^txt);
						match expAtt
							with ElementClasse then
								if (Acces^droiteAffectation) then
									AppelOuAcces^support := Acces^factory.createAttributUse(expAtt,exp.getClasseUse());
								else
									AppelOuAcces^support := Acces^factory.createAttributAssignment(expAtt,exp.getClasseUse());
								end
						end
					elseif (tmpc.containsMethode(identificateur^txt)) then
						expAtt := tmpc.getMethode(identificateur^txt);
						match expAtt
							with Methode then
								AppelOuAcces^support := Acces^factory.createMethodeUse(expAtt,exp.getClasseUse());
						end
					else
						error(ATTRIBUT_doesnt_exist,identificateur^txt);
					end
				with UndeclaredTypeImpl then
					write "LIAISONTARDIVE_AttributUse_NOT_IMPLEMENTED\n";
					error(LIAISONTARDIVE_ATTRIBUTUSE);
			end
		with AttributAssignmentImpl then
			tmpcti := exp.getType();
			match tmpcti
				with ClasseTypeImpl then
					tmpc := tmpcti.getClasse();
					if(tmpc.containsAttribut(identificateur^txt)) then
						expAtt := tmpc.getAttribut(identificateur^txt);
						match expAtt
							with ElementClasse then
								if (Acces^droiteAffectation) then
									AppelOuAcces^support := Acces^factory.createAttributUse(expAtt,exp.getClasseUse());
								else
									AppelOuAcces^support := Acces^factory.createAttributAssignment(expAtt,exp.getClasseUse());
								end
						end
					elseif (tmpc.containsMethode(identificateur^txt)) then
						expAtt := tmpc.getMethode(identificateur^txt);
						match expAtt
							with Methode then
								AppelOuAcces^support := Acces^factory.createMethodeUse(expAtt,exp.getClasseUse());
						end
					else
						error(ATTRIBUT_doesnt_exist,identificateur^txt);
					end
				with UndeclaredTypeImpl then
					write "LIAISONTARDIVE_AttributAssignment_NOT_IMPLEMENTED\n";
					error(LIAISONTARDIVE_ATTRIBUTASSIGNMENT);
			end
			

	end
end
}


Appel -> Arguments  #inh Acces #ast;
#inh {
local
	exp : Expression;
do
	exp := Appel^support;
	match exp
		with MethodeUseImpl then
			exp.setArguments(Arguments^ast);
			Acces^support := exp;
	end
end
}
#ast {
do
	Appel^ast := Acces^ast;
end
}




end
