----------------------------------------------- -*- text -*-
-- Langage MiniJava : Sous-ensemble du langage Java pour le projet STL 2016-2017
-- Sémantique : Construction de l'arbre abstrait
--                      Gestion de la table des symboles
--                      Typage
--                      Calcul des déplacements (Allocation mémoire)
--                      Génération de code TAM
-----------------------------------------------
option auto= true;
option version = 0.0.1 ;
option k=2;


--inh factory   : BlockFactory for Type, SuiteArgumentsGenericite, ArgumentGenericite, ArgumentsGenericite, InstanceGenericite, Parametre, SuiteParametres, Parametres, Genericite, HeritageClasse, SuiteParametresGenericite, ImplantationInterface, ParametresGenericite, TypeAtomique, SuiteTypeAtomique,ParametreGenericite, Interfaces, Interface, HeritageInterface, SuiteHeritageInterface, Signature, Classes, Classe, ElementClasse, AttributOuMethode, SuiteAttributOuMethode, Constructeur, Principale, MethodePrincipale, Bloc, Instructions, Instruction, Expression, SuiteExpressions, SuiteConditionnelle, Affectation, SuiteAffectation,Condition, SuiteCondition, SuiteTerme, Facteur, SuiteFacteur, Valeur, SuiteNouveau, Acces, ElementsClasse ;

--inh factory   : BlockFactory for Interfaces, Interface,ElementsInterface,ElementInterface, HeritageInterface, SuiteHeritageInterface, Signature, Parametre, TypeAtomique, SuiteTypeAtomique, ArgumentGenericite, Parametres;
--inh tds     : SymbolTable for Interfaces, Interface, ElementsInterface, ElementInterface, HeritageInterface, SuiteHeritageInterface, Parametre, ArgumentGenericite, Parametres;

--inh tds       : SymbolTable for Expressions, ArgumentGenericite, Programme, ParametreGenericite, Interfaces, Interface, HeritageInterface, SuiteHeritageInterface, ElementsInterface, Signature, Classes, Classe, HeritageClasse, ImplantationInterface, Principale, MethodePrincipale, Genericite, ParametresGenericite, SuiteParametresGenericite, SuiteHeritageGenericite, InstanceGenericite, ArgumentsGenericite, SuiteArgumentsGenericite, ElementClasse, Constructeur, AttributOuMethode, SuiteAttributOuMethode, Type, TypeAtomique, Parametres, Parametre, SuiteParametres, Bloc, Instructions, Instruction, Expression, SuiteExpressions, SuiteConditionnelle, Affectation, SuiteAffectation, Condition, SuiteCondition, SuiteTerme, Facteur, SuiteFacteur, SuiteNouveau, Arguments, Appel, Acces, ElementsClasse, AppelOuAcces  ;


--inh support     : Expression for Acces, Appel, AppelOuAcces;
--inh gauche  : Expression for SuiteCondition, SuiteAffectation, SuiteTerme, SuiteFacteur;
--inh alors : Block for SuiteConditionnelle;
--inh condition : Expression for SuiteConditionnelle; 
--inh innerArray : Type for SuiteTypeAtomique;
--inh type    : Type for SuiteNouveau; --Hh
--inh list    : LinkedList<Objet> for Interfaces;
--inh list    : LinkedList<Objet> for Classes;
--inh list    : LinkedList<Instruction> for Instructions;


--syn ast     : Objet for Interface;
--syn ast     : Objet for Classe;
--syn ast     : LinkedList<Objet> for Interfaces;
--syn ast     : LinkedList<Objet> for Classes;
--syn ast     : Expression for Expression, Affectation, SuiteAffectation, Facteur, SuiteFacteur, Condition, SuiteCondition, SuiteTerme, Acces, SuiteNouveau;
--syn ast     : Type for Type, TypeAtomique, SuiteTypeAtomique;
--syn ast     : Type for HeritageClasse;
--syn ast     : Block for Programme;
--syn ast     :Block for MethodePrincipale, Bloc, SuiteConditionnelle; --Hh
--syn ast     : Instruction for Instruction;
--syn ast     : ParametreGenericite for ParametreGenericite; --Euuuuuuh
--syn ast     : LinkedList<ParametreGenericite> for  ParametresGenericite, Genericite, SuiteParametresGenericite;
--syn ast     : LinkedList<ParametreGenericite> for Genericite;
--syn ast 	: ArgumentGenericite for ArgumentGenericite;
--syn ast     : LinkedList<ArgumentGenericite> for InstanceGenericite, ArgumentsGenericite, SuiteArgumentsGenericite;
--syn ast     : ElementInterface for ElementInterface, Signature;
--syn ast     : LinkedList<Type> for HeritageInterface, SuiteHeritageInterface;
--syn ast     : LinkedList<ElementInterface> for ElementsInterface;
--syn ast     : LinkedList<Parametre> for Parametres, SuiteParametres;
--syn ast     : LinkedList<ElementClasse> for ElementsClasse;
--syn ast     : Parametre for Parametre;
--syn ast     : Value for Valeur; 
--syn ast     : Classe for Principale;
--syn expressions : LinkedList<Expression> for Expressions, SuiteExpressions;
--syn acces   : DroitAcces for DroitAcces ;
--syn bin_op  : BinaryOperator for Comparatif, Additif;


--Interface(Interfaces, Interface)
inh factory       : BlockFactory for Interface, Interfaces;
inh tdsInterfaces : SymbolTable for Interface, Interfaces;
inh tdsClasses    : SymbolTable for Interface, Interfaces;
inh tdsFunctions  : FunctionSymbolTable for Interface, Interfaces;
inh tdsAttributs  : SymbolTable for Interface, Interfaces;
inh tds		        : SymbolTable for Interface, Interfaces;
syn ast 	        : Interface	for Interface;
syn ast         	: LinkedList<Interface> for Interfaces;

--Heritage Interface (HeritageInterface, HeritageInterfaces,SuiteHeritageInterface)
inh tds         	         : SymbolTable for HeritageInterface, SuiteHeritageInterface;
inh factory                : BlockFactory for HeritageInterface, SuiteHeritageInterface;
inh tdsInterfaces          : SymbolTable for HeritageInterface, SuiteHeritageInterface;
inh listInterfacesHeritage : LinkedList<String> for SuiteHeritageInterface;
syn ast 	                 : LinkedList<Interface> for HeritageInterface, SuiteHeritageInterface; --


--Element Interface (ElementInterface, ElementsInterface)
inh factory             : BlockFactory for ElementInterface, ElementsInterface;
inh tds		              : SymbolTable for ElementInterface, ElementsInterface;
inh tdsAttributs        : SymbolTable for ElementInterface, ElementsInterface;
inh tdsInterfaces       : SymbolTable for ElementInterface, ElementsInterface;
inh tdsClasses          : SymbolTable for ElementInterface, ElementsInterface;
inh tdsFunctions        : FunctionSymbolTable for ElementInterface, ElementsInterface;
inh interfaceCourrante  : String for ElementsInterface, ElementInterface;
syn ast 	              : ElementInterface for ElementInterface;
syn ast 	              : LinkedList<ElementInterface> for ElementsInterface;


--Signature
inh tds 	             : SymbolTable for Signature;
inh tdsInterfaces      : SymbolTable for Signature;
inh tdsClasses         : SymbolTable for Signature;
inh tdsFunctions       : FunctionSymbolTable for Signature;
inh tdsAttributs       : SymbolTable for Signature;
inh factory            : BlockFactory for Signature;
inh interfaceCourrante : String for Signature;
syn ast 	             : Signature for Signature;

-- --Genericite (Genericite,InstanceGenericite, ArgumentGenericite, ArgumentsGenericite, SuiteArgumentsGenericite,
-- --            ParametresGenericite, SuiteParametresGenericite, ParametreGenericite, HeritageGenericite, SuiteHeritageGenericite)
-- inh tds		  : SymbolTable for Genericite, InstanceGenericite, ArgumentGenericite, ArgumentsGenericite, SuiteArgumentsGenericite, ParametresGenericite, SuiteParametresGenericite, ParametreGenericite, HeritageGenericite, SuiteHeritageGenericite;
-- inh factory : BlockFactory for Genericite, InstanceGenericite, ArgumentGenericite, ArgumentsGenericite, SuiteArgumentsGenericite, ParametresGenericite, SuiteParametresGenericite, ParametreGenericite, HeritageGenericite, SuiteHeritageGenericite;
-- syn ast 	  : ArgumentGenericite for ArgumentGenericite;
-- syn ast     : ParametreGenericite for ParametreGenericite;
-- syn ast 	  : LinkedList<ParametreGenericite> for Genericite, ParametresGenericite, SuiteParametresGenericite; -- Changé temporairement (on a pas ParamGen..LinkedList<ArgumentGenericite>.) -> LinkedList<ParametreGenericite> for Genericite;
-- syn ast 	  : LinkedList<Type> for ArgumentsGenericite, SuiteArgumentsGenericite;
-- syn ast 	  : LinkedList<Type> for InstanceGenericite;
-- syn ast     : LinkedList<Type> for HeritageGenericite, SuiteHeritageGenericite;

--Parametre (Parametres, SuiteParametres)
inh tds 	        : SymbolTable for Parametre, Parametres, SuiteParametres;
inh tdsInterfaces : SymbolTable for Parametre, Parametres, SuiteParametres;
inh tdsFunctions  : FunctionSymbolTable for Parametre, Parametres, SuiteParametres;
inh tdsAttributs  : SymbolTable for Parametre, Parametres, SuiteParametres;
inh tdsParametres : SymbolTable for Parametre, Parametres, SuiteParametres;
inh factory       : BlockFactory for Parametre, Parametres, SuiteParametres;
syn ast 	        : Parametre for Parametre;
syn ast 	        : LinkedList<Parametre> for Parametres, SuiteParametres;

--Classe (Classe, Classes)
inh tdsInterfaces : SymbolTable for Classes, Classe;
inh tdsFunctions  : FunctionSymbolTable for Classes, Classe;
inh tdsAttributs  : SymbolTable for Classes, Classe;
inh tdsClasses    : SymbolTable for Classes, Classe;
inh tds           : SymbolTable for Classes, Classe;
inh factory       : BlockFactory for Classe,Classes;
syn ast           : LinkedList<Classe> for Classes;
syn ast           : Classe for Classe;


--Implantation Interface
syn ast           : Classe for ImplantationInterface;
inh tds           : SymbolTable for ImplantationInterface;
inh tdsClasses    : SymbolTable for ImplantationInterface;
inh tdsAttributs  : SymbolTable for ImplantationInterface;
inh tdsInterfaces : SymbolTable for ImplantationInterface;
inh tdsFunctions  : FunctionSymbolTable for ImplantationInterface;
inh factory       : BlockFactory for ImplantationInterface;
inh listInterfacesHeritage : LinkedList<String> for ImplantationInterface;

--Heritage Classe
syn ast           : LinkedList<Classe> for HeritageClasse;
inh tds           : SymbolTable for HeritageClasse;
inh tdsClasses    : SymbolTable for HeritageClasse;
inh tdsAttributs  : SymbolTable for HeritageClasse;
inh tdsInterfaces : SymbolTable for HeritageClasse;
inh tdsFunctions  : FunctionSymbolTable for HeritageClasse;
inh factory       : BlockFactory for HeritageClasse;

--Elements Classe (ElementClasse, AttributOuMethode, Constructeur)
inh factory       : BlockFactory for ElementsClasse,ElementClasse, AttributOuMethode, SuiteAttributOuMethode, Constructeur;
inh classeCourrante : String for ElementsClasse, ElementClasse, AttributOuMethode, SuiteAttributOuMethode, Constructeur;
syn ast           : ElementClasse for ElementClasse, AttributOuMethode, Constructeur, SuiteAttributOuMethode;
syn ast           : LinkedList<ElementClasse> for ElementsClasse;
inh tds           : SymbolTable for AttributOuMethode,SuiteAttributOuMethode, Constructeur, ElementsClasse, ElementClasse;
inh tdsClasses    : SymbolTable for AttributOuMethode,SuiteAttributOuMethode, Constructeur, ElementsClasse, ElementClasse;
inh tdsAttributs  : SymbolTable for AttributOuMethode,SuiteAttributOuMethode, Constructeur, ElementsClasse, ElementClasse;
inh tdsInterfaces : SymbolTable for AttributOuMethode,SuiteAttributOuMethode, Constructeur, ElementsClasse, ElementClasse;
inh tdsFunctions  : FunctionSymbolTable for AttributOuMethode,SuiteAttributOuMethode, Constructeur, ElementsClasse, ElementClasse;
inh droit         : DroitAcces for ElementClasse,AttributOuMethode,SuiteAttributOuMethode,Constructeur;
inh ident         : String for SuiteAttributOuMethode;
inh static        : boolean for AttributOuMethode,SuiteAttributOuMethode;
inh type          : Type for SuiteAttributOuMethode;


--DroitAcces
syn acces           : DroitAcces for DroitAcces;

--Type (Atomique,SuiteAtomique)
inh tds 	     : SymbolTable for Type, TypeAtomique, SuiteTypeAtomique;
inh factory    : BlockFactory for Type, TypeAtomique, SuiteTypeAtomique;
inh innerArray : Type for SuiteTypeAtomique;
syn ast 	     : Type for Type, TypeAtomique, SuiteTypeAtomique;

-- Bloc
syn ast        : Block for Bloc;

-- --Expression
-- inh factory       : BlockFactory for Expression;
-- inh tdsInterfaces : SymbolTable for Expression;
-- inh tdsClasses    : SymbolTable for Expression;
-- inh tdsFunctions  : FunctionSymbolTable for Expression;
-- inh tdsAttributs  : SymbolTable for Expression;
-- inh tds           : SymbolTable for Expression;
-- syn ast           : Expression for Expression;
--Programme
syn ast 	: Programme for Programme;



space separateur        is    "[\n\r\t ]+";
space commentaire       is    "\/\/.*\n";
sugar accolade_ouvrante     is    "\{";  
sugar accolade_fermante     is    "\}";  
sugar crochet_ouvrant     is    "\[";  
sugar crochet_fermant     is    "\]";  
sugar parenthese_ouvrante   is    "\(";
sugar parenthese_fermante   is    "\)";
sugar inferieur         is    "\<";  
sugar superieur         is    "\>";  
sugar inferieur_egal      is    "\<=";  
sugar superieur_egal      is    "\>=";  
sugar point           is    "\.";  
sugar point_virgule       is    ";";  
sugar virgule         is    ",";
sugar affectation       is    "=";
sugar egalite         is    "==";  
sugar different         is    "\!=";  
sugar addition          is    "\+";
sugar soustraction        is    "\-";
sugar ou            is    "\|\|";  
sugar multiplication      is    "\*";
sugar division          is    "/";
sugar modulo          is    "%";
sugar adresse         is    "&";  
sugar negation          is    "\!";  
sugar et            is    "&&";  
sugar vrai            is    "true";
sugar faux            is    "false";
sugar si            is    "if";
sugar sinon           is    "else";
sugar afficher          is    "print";  
sugar nouveau         is    "new";  
sugar tant_que          is    "while";  
sugar retour          is    "return";  
sugar type_int          is    "int";
sugar type_bool         is    "boolean";  
sugar type_char         is    "char";        
sugar type_String       is    "String";        
sugar vide            is    "void";     
sugar nul           is    "null";     
sugar choix           is    "\?";         
sugar deux_points       is    ":";          
sugar interface         is    "interface";     
sugar classe          is    "class";      
sugar extension         is    "extends";      
sugar implantation        is    "implements";      
sugar public          is    "public";    
sugar protege         is    "protected";    
sugar prive           is    "private";     
sugar statique          is    "static";       
sugar final           is    "final";       
sugar principale        is    "main";  
term   chaine         is    "\"([^\"]|\\\")*\"";  
term   caractere        is    "\'[^\']\'";  
term   entier         is    "[0-9]+";
term   identificateur     is    "[a-z_][a-zA-Z0-9_]*"; 
term   identificateur_type    is    "[A-Z][a-zA-Z0-9_]*"; 



Programme -> #factory Interfaces #factory2 Classes #ast3;
global
  tds_Interfaces :SymbolTable;
  tds_Classes : SymbolTable;
  tds_Functions : FunctionSymbolTable;
  tds_Attributs : SymbolTable;

#factory {
do
  tds_Interfaces := new SymbolTable();
  tds_Classes := new SymbolTable();
  tds_Functions := new FunctionSymbolTable();
  tds_Attributs := new SymbolTable();

  Interfaces^tdsInterfaces := tds_Interfaces;
  Interfaces^tdsClasses := tds_Classes;
  Interfaces^tdsFunctions := tds_Functions;
  Interfaces^tdsAttributs := tds_Attributs;
  Interfaces^tds := new SymbolTable();
  Interfaces^factory := new BlockFactoryImpl();
  
end
}
#factory2 {
do
  Classes^tdsInterfaces := tds_Interfaces;
  Classes^tdsClasses := tds_Classes;
  Classes^tdsFunctions := tds_Functions;
  Classes^tdsAttributs := tds_Attributs;
  Classes^tds := new SymbolTable();
  Classes^factory := new BlockFactoryImpl();
end
}
#ast3 {
local
  facto : BlockFactory;
do
  facto := new BlockFactoryImpl();
  Programme^ast := facto.createProgramme(Interfaces^ast,Classes^ast);
  --Plus tard createProgramme(Interfaces^ast,Classes^ast,Princiapel^ast) !? --Hh non
end
}



Interfaces -> Interface #interfaceMultiple Interfaces #ast;
#interfaceMultiple{
do
  if (Interfaces^tdsInterfaces.contains(Interface^ast.getName())) then
    error(INTERFACE_already_defined, Interface^ast.getName());
  else
    Interfaces^tdsInterfaces.register(Interface^ast);
  end
end
}


#ast{
do
  Interfaces1^ast.addFirst(Interface^ast);
  Interfaces^ast := Interfaces1^ast;
end
}


Interfaces -> #ast;
#ast {
do
  Interfaces^ast := new LinkedList<Interface>();
end
}



--interface identificateur_type Genericit HeritageInterface [...]
Interface -> interface identificateur_type HeritageInterface accolade_ouvrante #inh ElementsInterface accolade_fermante #ast;
#inh {
do
  ElementsInterface^tds := new SymbolTable(); -- Dans règle l228 ?
  ElementsInterface^interfaceCourrante := identificateur_type^txt;
end
}
#ast {
local
  interface : Interface;
do
  interface := Interface^factory.createInterface(identificateur_type^txt, HeritageInterface^ast, ElementsInterface^ast);
  Interface^ast := interface;
end 
}

--#ast {
--do
--  if (Interface^tds.knows(identificateur_type^txt)) then
--    error(TYPE_already_defined, identificateur_type^txt);
--  else
--    if Genericite^ast = nil then
--      if HeritageInterface^ast = nil then
--        Interface^ast := Interface^factory.createInterface(identificateur_type^txt, ElementsInterface^ast);
--      else
--        Interface^ast := Interface^factory.createInterface(HeritageInterface^ast, identificateur_type^txt,ElementsInterface^ast);
--      end
--    else
--      if HeritageInterface^ast = nil then   --Genericite^ast est un Type ?
--        Interface^ast := Interface^factory.createInterface(identificateur_type^txt,Genericite^ast,ElementsInterface^ast);
--      else
--        Interface^ast := Interface^factory.createInterface(identificateur_type^txt, Genericite^ast, HeritageInterface^ast, ElementsInterface^ast);
--      end
--    end
--  end
--end
--}



-- extension identificateur_type InstanceGenericite [...]
HeritageInterface -> extension identificateur_type #inh SuiteHeritageInterface #ast ;
-- #ast{
-- local
--   o : Optional<Declaration>;
--   d : Declaration;
-- do
--   HeritageInterface^ast := SuiteHeritageInterface^ast;
--   if HeritageInterface^tds.knows(identificateur_type^txt) then
--     o := HeritageInterface^tds.get(identificateur_type^txt);
--     d := o.get();
--     match d
--     with Interface then
--       if InstanceGenericite^ast = nil then
--         SuiteHeritageInterface^ast.add(HeritageInterface^factory.createGenericType(d));
--       else
--         SuiteHeritageInterface^ast.add(HeritageInterface^factory.createGenericType(d,InstanceGenericite^ast));
--       end
--        HeritageInterface^ast := SuiteHeritageInterface^ast;

--     else
--       error(TYPE_not_an_interface, identificateur_type^txt);
--     end
--   else
--     error(TYPE_unknown,identificateur_type^txt);
--   end
-- end
-- }

-- #inh{ --Hh
-- do
--     --InstanceGenericite^support := HeritageInterface^ast;
-- end
-- }
#inh{
local
  listInterfaces : LinkedList<String>;
do
  if(HeritageInterface^tdsInterfaces.contains(identificateur_type^txt)) then
    listInterfaces := new LinkedList<String>();
    listInterfaces.add(identificateur_type^txt);
    SuiteHeritageInterface^listInterfacesHeritage := listInterfaces;
  else 
    error(INTERFACE_unknown_ident, identificateur_type^txt);
  end
end
}

#ast{
local
  o : Optional<Declaration>;
  d : Declaration;
do
  if (HeritageInterface^tdsInterfaces.knows(identificateur_type^txt)) then
    o := HeritageInterface^tdsInterfaces.get(identificateur_type^txt);
    d := o.get();
    match d 
      with Interface then SuiteHeritageInterface^ast.addFirst(d);
    else
      error(HERITAGE_not_interface, identificateur_type^txt);
    end
  else
    error(HERITAGE_doesnt_exist, identificateur_type^txt);
  end
  HeritageInterface^ast := SuiteHeritageInterface^ast;
end
}


HeritageInterface -> #ast;
#ast{
do
  HeritageInterface^ast := new LinkedList<Interface>();
end
}

--virgule identificateur_type InstanceGenericite [...]
SuiteHeritageInterface -> virgule identificateur_type #inh SuiteHeritageInterface #ast;
-- #ast{
-- local
--   o : Optional<Declaration>;
--   d : Declaration;
-- do
--   if SuiteHeritageInterface^tds.knows(identificateur_type^txt) then
--     if SuiteHeritageInterface^tds.contains(identificateur_type^txt) then
--       error(HERITAGE_already_defined,identificateur_type^txt);
--     else
--       o := SuiteHeritageInterface^tds.get(identificateur_type^txt);
--       d := o.get();
--       match d
--       with Interface then
--         if InstanceGenericite^ast = nil then
--           SuiteHeritageInterface1^ast.add(SuiteHeritageInterface^factory.createGenericType(d));
--         else
--           SuiteHeritageInterface1^ast.add(SuiteHeritageInterface^factory.createGenericType(d,InstanceGenericite^ast));
--         end
--       else
--         error(TYPE_not_an_interface,identificateur_type^txt);
--       end
--     end
--     SuiteHeritageInterface^ast := SuiteHeritageInterface1^ast;  --Hh
--   else
--     error(TYPE_unknown,identificateur_type^txt);
--   end
-- end
-- }

#inh {
do
  if(SuiteHeritageInterface^tdsInterfaces.contains(identificateur_type^txt)) then
    SuiteHeritageInterface^listInterfacesHeritage.add(identificateur_type^txt);
    SuiteHeritageInterface1^listInterfacesHeritage := SuiteHeritageInterface^listInterfacesHeritage;
  else
    error(HERITAGE_doesnt_exist,identificateur_type^txt);
  end
end
}

#ast{
local
  o : Optional<Declaration>;
  d : Declaration;
do
  SuiteHeritageInterface^ast := SuiteHeritageInterface1^ast;
  if(SuiteHeritageInterface^tdsInterfaces.knows(identificateur_type^txt)) then
    o := SuiteHeritageInterface^tdsInterfaces.get(identificateur_type^txt);
    d := o.get();
    match d
      with Interface then SuiteHeritageInterface^ast.addFirst(d); 
    else
      error(HERITAGE_not_interface, identificateur_type^txt);
    end
  else
    error(HERITAGE_dont_exist, identificateur_type^txt);
  end
end
}

SuiteHeritageInterface -> #ast;
#ast{
do
  SuiteHeritageInterface^ast := new LinkedList<Interface>();
end
}


ElementsInterface -> ElementInterface #register ElementsInterface #ast;
#register {
do
  ElementsInterface^tds.register(ElementInterface^ast);
end
}

#ast{
do
  ElementsInterface1^ast.addFirst(ElementInterface^ast);
  ElementsInterface^ast := ElementsInterface1^ast;
end
}

ElementsInterface -> #ast;
#ast{
do
  ElementsInterface^ast := new LinkedList<ElementInterface>();
end
}

-- ------------- Pour éviter de s'embeter avec les expressions
-- ElementInterface -> final statique Type identificateur affectation #attribut Expression point_virgule #ast;
-- #attribut{
-- do
--   Expression^tdsAttributs := new SymbolTable();
-- end
-- }


-- #ast{
-- local
--   finalsf : FinalStaticField;
-- do
--   if (ElementInterface^tds.knows(identificateur^txt)) then
--     error(FINALSTATICFIELD_ident_already_defined);
--   else
--     finalsf := ElementInterface^factory.createFinalStaticField(identificateur^txt,Type^ast, Expression^ast);
--     ElementInterface^ast := finalsf;
--     ElementInterface^tdsAttributs.register(staticField, ElementInterface^interfaceCourrante);
--   end
-- end
-- }

ElementInterface -> Signature point_virgule #ast;
#ast{
do
  ElementInterface^ast := Signature^ast;
  ElementInterface^tdsFunctions.registerSign(Signature^ast,ElementInterface^interfaceCourrante);
end
}


Signature -> vide identificateur parenthese_ouvrante #tds Parametres parenthese_fermante #ast;
#tds{
do
  Parametres^tdsParametres := new SymbolTable();
end
}

#ast{
do
  if(Signature^tds.knows(identificateur^txt)) then
    error(SIGNATURE_ident_already_defined);
  else
    Signature^ast := Signature^factory.createSignature(identificateur^txt,Parametres^ast, Signature^interfaceCourrante);
  end
end
}  
 
Signature -> Type identificateur parenthese_ouvrante #tds Parametres parenthese_fermante #ast;
#tds{
do
  Parametres^tdsParametres := new SymbolTable();
end
}

#ast{
do
  if(Signature^tds.knows(identificateur^txt)) then
    error(SIGNATURE_ident_already_defined);
  else
    Signature^ast := Signature^factory.createSignature(identificateur^txt,Type^ast,Parametres^ast, Signature^interfaceCourrante );
  end
end
}  



Parametres -> #ast ;
#ast {
do
   Parametres^ast := new LinkedList<Parametre>();
end
}

Parametres -> Parametre #register SuiteParametres #ast ;
#register {
do
  Parametres^tdsParametres.register(Parametre^ast);
end
}

#ast {
do 
   SuiteParametres^ast.addFirst(Parametre^ast);
   Parametres^ast := SuiteParametres^ast;  
end 
}


SuiteParametres -> #ast;
#ast {
do
   SuiteParametres^ast := new LinkedList<Parametre>();
end
}

SuiteParametres -> virgule Parametre #register SuiteParametres #ast;
#register {
do
  SuiteParametres^tdsParametres.register(Parametre^ast);
end
}


#ast {
do
  SuiteParametres1^ast.addFirst(Parametre^ast); 
   SuiteParametres^ast := SuiteParametres1^ast; 
end
}

Parametre -> Type identificateur #ast;
#ast {
do
  if Parametre^tds.contains(identificateur^txt) then
    error(PARAMETRE_already_defined, identificateur^txt);
  else
    Parametre^ast := Parametre^factory.createParametre(identificateur^txt, Type^ast);
  end
end
}

--------------------------------------
--l 348 > 441 (CLASSES)
--------------------------------------


Classes -> Classe #list Classes #ast;
#ast {
do
  Classes1^ast.addFirst(Classe^ast);
  Classes^ast := Classes1^ast;
end
}

#list {
do
  if(Classes^tdsClasses.contains(Classe^ast.getName())) then
    error(CLASSE_already_defined,Classe^ast.getName());
  else
    Classes^tdsClasses.register(Classe^ast);
  end
end
}

Classes -> #ast;
#ast {
do
  Classes^ast := new LinkedList<Classe>();
end
}

--Classe -> classe  identificateur_type Genericite HeritageClasse ImplantationInterface accolade_ouvrante ElementsClasse accolade_fermante #ast;
Classe -> classe  identificateur_type HeritageClasse #inhlist ImplantationInterface accolade_ouvrante #inh ElementsClasse accolade_fermante #ast;
#inhlist {
do
  ImplantationInterface^listInterfacesHeritage := new LinkedList<Interface>();
end
}
#inh {
do
  ElementsClasse^tds := new SymbolTable();
  ElementsClasse^classeCourrante := identificateur_type^txt;
end
}



#ast {
do
  Classe^ast := Classe^factory.createClasse(identificateur_type^txt,HeritageClasse^ast,ImplantationInterface^ast,ElementsClasse^ast);
end
}

--HeritageClasse -> extension identificateur_type #inh InstanceGenericite #ast ;
HeritageClasse -> extension identificateur_type #ast ;
--#inh {
--local
--  f : Optional<Declaration>;
--  d : Declaration;
--do
--   if HeritageClasse^tds.knows(identificateur_type^txt) then
--     f := HeritageClasse^tds.get(identificateur_type^txt);
--     d := f.get();
--     match d
--     with GenericType then InstanceGenericite^support := HeritageClasse^factory.createGenericTypeUse(d);
--     end
--   else
--     error(TYPE_unknown,identificateur_type^txt);
--   end
-- end
-- }

#ast {
local
  o : Optional<Declaration>;
  d : Declaration;
do
  if(HeritageClasse^tdsClasses.knows(identificateur_type^txt)) then
  o := HeritageClasse^tdsClasses.get(identificateur_type^txt);
  d := o.get();
  match d
    with Classe then HeritageClasse^ast := new LinkedList<Classe>(o); --Il ne peut y avoir qu'un seul heritageClasse -> optionnal ?!
    else
      error (HERITAGE_not_classe,identificateur_type^txt);
    end
  else
    error(HERITAGE_doesnt_exist);
  end
end
}


HeritageClasse -> #ast;
#ast {
do
  HeritageClasse^ast := new LinkedList<Classe>();
end
}


-- ImplantationInterface -> implantation identificateur_type InstanceGenericite SuiteHeritageInterface #ast; 
ImplantationInterface -> implantation identificateur_type #inh SuiteHeritageInterface #ast;
#inh{
local
  listInterfaces : LinkedList<String>;
do
  if(ImplantationInterface^tdsInterfaces.contains(identificateur_type^txt)) then
    listInterfaces := new LinkedList<String>();
    listInterfaces.add(identificateur_type^txt);
    SuiteHeritageInterface^listInterfacesHeritage := listInterfaces;
  else 
    error(INTERFACE_unknown_ident, identificateur_type^txt);
  end
end
}

#ast{
local
  o : Optional<Declaration>;
  d : Declaration;
do
  if(ImplantationInterface^tdsInterfaces.knows(identificateur_type^txt)) then
    o := ImplantationInterface^tdsInterfaces.get(identificateur_type^txt);
    d := o.get();
    match d
      with Interface then SuiteHeritageInterface^ast.addFirst(d); 
    else
      error(HERITAGE_not_interface, identificateur_type^txt);
    end
  else
    error(HERITAGE_dont_exist, identificateur_type^txt);
  end
    ImplantationInterface^ast := SuiteHeritageInterface^ast;
end
}


ImplantationInterface -> #ast;
#ast {
do
  ImplantationInterface^ast := new LinkedList<Interface>();
end
}

--------------------------------------
--l 602 > 714 (ELMTS CLASSES)
--------------------------------------

ElementsClasse -> DroitAcces #inh ElementClasse #register ElementsClasse #ast ;
#inh {
do
  ElementClasse^droit := DroitAcces^acces;
end
}
#register {
do
  ElementsClasse^tds.register(ElementClasse^ast);
end
}

#ast {
do
  ElementsClasse1^ast.addFirst(ElementClasse^ast);
  ElementsClasse^ast := ElementsClasse1^ast;
end
}
  
ElementsClasse -> #ast ;
#ast {
do
   ElementsClasse^ast := new LinkedList<ElementClasse>();
end
}

DroitAcces -> public #ast ;
#ast {
do
   DroitAcces^acces := DroitAcces.Public;
end
}

DroitAcces -> protege #ast ;
#ast {
do
   DroitAcces^acces := DroitAcces.Protected;
end
}
 
DroitAcces -> prive #ast ;  
#ast {
do
   DroitAcces^acces := DroitAcces.Private;
end
}
 
-- TODO
ElementClasse -> statique #inh AttributOuMethode #ast;
#inh {
do
  AttributOuMethode^static := true;
end
}

#ast {
do
  ElementClasse^ast := AttributOuMethode^ast;
end
}
 
-- TODO 
ElementClasse -> #inh AttributOuMethode #ast;
#inh {
do
  AttributOuMethode^static := false;
end
}
#ast {
do
  ElementClasse^ast := AttributOuMethode^ast;
end
}
 

ElementClasse -> Constructeur #ast;  
#ast {
do
  ElementClasse^ast := Constructeur^ast;
end
}
    

AttributOuMethode -> Type identificateur #inh SuiteAttributOuMethode #ast;
#inh {
do
  SuiteAttributOuMethode^ident := identificateur^txt;
  SuiteAttributOuMethode^type := Type^ast;
end
}
#ast {
do
  -- if AttributOuMethode^tds.knows(identificateur^txt) then --(contains ou knows je sais plus ?)
  --   error(IDENT_already_used, identificateur^txt);
  -- else
  --   AttributOuMethode^ast := SuiteAttributOuMethode^ast;
  --   AttributOuMethode^tds.register(SuiteAttributOuMethode^ast);
  -- end
  AttributOuMethode^ast := SuiteAttributOuMethode^ast;
end
}
 

AttributOuMethode -> vide identificateur parenthese_ouvrante #inh Parametres parenthese_fermante Bloc #ast ;
#inh {
do
  Parametres^tdsParametres := new SymbolTable();
end
}

#ast {
local
  met : Methode;
do
  met := AttributOuMethode^factory.createMethode(identificateur^txt,AttributOuMethode^classeCourrante,AtomicType.VoidType,AttributOuMethode^droit,AttributOuMethode^static,Parametres^ast,Bloc^ast);
  if AttributOuMethode^tdsFunctions.containFun(met) then --(contains ou knows je sais plus ?)
    error(IDENT_already_used, identificateur^txt);
  else
    AttributOuMethode^ast := met;
    AttributOuMethode^tdsFunctions.registerFunction(met);
  end
end
}
 

SuiteAttributOuMethode -> point_virgule #ast;
#ast {
local
  att : Attribut;
do
  if(SuiteAttributOuMethode^tdsAttributs.knows(SuiteAttributOuMethode^ident)) then
    error(IDENT_already_used, SuiteAttributOuMethode^ident);
  else
    att := SuiteAttributOuMethode^factory.createAttribut(SuiteAttributOuMethode^ident, SuiteAttributOuMethode^type, SuiteAttributOuMethode^droit, SuiteAttributOuMethode^static);
    SuiteAttributOuMethode^ast := att;
    SuiteAttributOuMethode^tdsAttributs.register(att);
  end
end
}
 

SuiteAttributOuMethode -> parenthese_ouvrante #inh Parametres parenthese_fermante Bloc #ast ;
#inh {
do
  Parametres^tdsParametres := new SymbolTable();
end
}

#ast {
local
  met : Methode;
do
  met := SuiteAttributOuMethode^factory.createMethode(SuiteAttributOuMethode^ident, SuiteAttributOuMethode^classeCourrante, SuiteAttributOuMethode^type, SuiteAttributOuMethode^droit, SuiteAttributOuMethode^static, Parametres^ast,Bloc^ast);
  if(SuiteAttributOuMethode^tdsFunctions.containFun(met)) then
    error(IDENT_already_used, SuiteAttributOuMethode^ident);
  else
    SuiteAttributOuMethode^ast := met;
    SuiteAttributOuMethode^tdsFunctions.registerFunction(met);
  end
end
}

Constructeur -> identificateur_type parenthese_ouvrante #inh Parametres parenthese_fermante Bloc #ast ;
#inh {
do
  Parametres^tdsParametres := new SymbolTable();
end
}

#ast {
local
  cons : Constructeur;
do
  if(Constructeur^classeCourrante = identificateur_type^txt) then
    cons := Constructeur^factory.createConstructeur(identificateur_type^txt, Constructeur^droit, Parametres^ast, Bloc^ast);
    if(Constructeur^tdsFunctions.containCons(cons)) then
      error(CONSTRUCTOR_signature_already_exists,identificateur_type^txt);
    else
      Constructeur^ast := cons;
      Constructeur^tdsFunctions.registerConstructeur(cons);
    end
  else
    error(CONSTRUCTOR_name_missmatch, identificateur_type^txt);
  end
end
}

--------------------------------------
-- l XXX  Bloc
--------------------------------------

Bloc -> #ast ;
#ast{
do
  Bloc^ast := nil;
end
}

--------------------------------------
--l 664 > 702 (TYPES)
--------------------------------------

Type -> TypeAtomique #inhArray SuiteTypeAtomique #ast;
#inhArray {
do
  SuiteTypeAtomique^innerArray := TypeAtomique^ast;
end
}

#ast {
do
  Type^ast := SuiteTypeAtomique^ast;
end
}




TypeAtomique -> type_bool #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createBooleanType();  
end
}

TypeAtomique -> type_int  #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createIntegerType();  
end
}
 
TypeAtomique -> type_char #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createCharType();  
end
}

TypeAtomique -> type_String #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createStringType();  
end
}

--TypeAtomique -> identificateur_type InstanceGenericite ; -- A DECOMMENTER TODO

SuiteTypeAtomique -> crochet_ouvrant crochet_fermant #inhArray SuiteTypeAtomique #ast;
#inhArray {
do
  SuiteTypeAtomique1^innerArray := SuiteTypeAtomique^factory.createArrayType(SuiteTypeAtomique^innerArray);
end
}

#ast {
do
  SuiteTypeAtomique^ast := SuiteTypeAtomique1^ast;
end
}

SuiteTypeAtomique -> #ast;
#ast {
do
  SuiteTypeAtomique^ast := SuiteTypeAtomique^innerArray;
end
}


----------------------------------------------------------------------------------------------------
--
-- Classes, Blocs [...]
--
----------------------------------------------------------------------------------------------------

---------------------------
--l463 > 519 Genericite
---------------------------
-- Genericite -> inferieur ParametresGenericite superieur #ast ;
-- #ast {
-- do
--    Genericite^ast := ParametresGenericite^ast;
-- end
-- }

-- Genericite -> #ast;
-- #ast {
-- do
--   Genericite^ast := nil;
-- end
-- }

-- ParametresGenericite -> ParametreGenericite SuiteParametresGenericite #ast;
-- #ast {
-- do
--   SuiteParametresGenericite^ast.addFirst(ParametreGenericite^ast);
--   ParametresGenericite^ast := SuiteParametresGenericite^ast;
--   ParametreGenericite^tds.register(ParametreGenericite^ast);

-- end
-- }

-- SuiteParametresGenericite -> virgule ParametreGenericite SuiteParametresGenericite #ast;
-- #ast {
-- do
--   SuiteParametresGenericite1^ast.addFirst(ParametreGenericite^ast);
--   SuiteParametresGenericite^ast := SuiteParametresGenericite1^ast;
--   SuiteParametresGenericite^tds.register(ParametreGenericite^ast);
-- end
-- }
-- SuiteParametresGenericite -> #ast;
-- #ast {
-- do
--    SuiteParametresGenericite^ast := new LinkedList<ParametreGenericite>();
-- end
-- }

-- ParametreGenericite -> identificateur_type HeritageGenericite #ast ; 
-- #ast {
-- do
--   if ParametreGenericite^tds.contains(identificateur_type^txt) then
--     error(GENERICITE_already_defined, identificateur_type^txt);
--   else
--     ParametreGenericite^ast := ParametreGenericite^factory.createGenericParameter(identificateur_type^txt, HeritageGenericite^ast);
--   end
-- end
-- } 
 
-- ParametreGenericite -> choix HeritageGenericite #ast ;  
-- #ast {
-- do
--   ParametreGenericite^ast := ParametreGenericite^factory.createGenericParameter(HeritageGenericite^ast);
-- end
-- }

---------------------------------
--l521 > 564 - HeritageGenericite
---------------------------------

-- TODO <? extends T Suite> = on crée un parametre generique qui recupere les trucs de suiteHeritageGenericite
-- Avant HeritageGenericite -> extension identificateur_type SuiteHeritageGenericite #ast;
-- HeritageGenericite -> extension identificateur_type InstanceGenericite SuiteHeritageGenericite #ast;
-- #ast {
-- local
--     f : Optional<Declaration>;
--     d : Declaration;
-- do
--     if HeritageGenericite^tds.knows(identificateur_type^txt) then
--         f := HeritageGenericite^tds.get(identificateur_type^txt);
--         d := f.get();
--         if (InstanceGenericite^ast = nil) then
--             match d
--             with Objet then
--                 SuiteHeritageGenericite^ast.addFirst(d.getType());
--                 HeritageGenericite^ast := SuiteHeritageGenericite^ast;
--             else
--                 error(DECL_not_an_object, identificateur_type^txt);
--             end
--         else
--             match d
--             with Objet then
--                 SuiteHeritageGenericite^ast.addFirst(HeritageGenericite^factory.createTypeGenerique(d, InstanceGenericite^ast));
--                 HeritageGenericite^ast := SuiteHeritageGenericite^ast;
--             else
--                 error(DECL_not_an_object, identificateur_type^txt);
--             end
--         end
--     else
--         error(Undefined_ident,identificateur_type^txt);
--     end
-- end
-- }

-- TO DO : <?> = on crée juste un parametre generique quelconque --Hh -> pas sur sur... (Vivian ?)
-- HeritageGenericite -> #ast;
-- #ast {
-- do
--   HeritageGenericite^ast := nil;
-- end
-- }

-- TODO <? extends T & Interface1 (& Interface2 ...) >
-- Avant: SuiteHeritageGenericite -> adresse identificateur_type SuiteHeritageGenericite #ast; ???
-- SuiteHeritageGenericite -> adresse identificateur_type InstanceGenericite SuiteHeritageGenericite #ast;
-- #ast {
-- local
--     f : Optional<Declaration>;
--     d : Declaration;
-- do
--     if SuiteHeritageGenericite^tds.knows(identificateur_type^txt) then
--         f := SuiteHeritageGenericite^tds.get(identificateur_type^txt);
--         d := f.get();
--         if (InstanceGenericite = nil) then
--             match d
--             with Objet then 
--                 SuiteHeritageGenericite1^ast.addFirst(d.getType());
--                 SuiteHeritageGenericite^ast := SuiteHeritageGenericite1^ast;
--             else
--                 error(DECL_not_an_object, identificateur_type^txt);
--             end
--         else
--             match d
--             with Objet then 
--                 SuiteHeritageGenericite1^ast.addFirst(SuiteHeritageGenericite^factory.createTypeGenerique(d, InstanceGenericite^ast));
--                 SuiteHeritageGenericite^ast := SuiteHeritageGenericite1^ast;
--             else
--                 error(DECL_not_an_object, identificateur_type^txt);
--             end
--         end
--     else
--         error(Undefined_ident, identificateur_type^txt);
--     end
-- end
-- }

-- -- TODO <? extends T >
-- SuiteHeritageGenericite -> #ast;
-- #ast {
-- do
--   SuiteHeritageGenericite^ast := new LinkedList<Objet>();
-- end
-- }


---------------------------------
--l567 > 599 - InstanceGenericite
---------------------------------

-- InstanceGenericite -> #ast;
-- #ast{
-- do
--   InstanceGenericite^ast := nil;
-- end
-- }

-- InstanceGenericite -> inferieur ArgumentsGenericite superieur #ast;
-- #ast{
-- do
--   InstanceGenericite^ast := ArgumentsGenericite^ast;
-- end
-- }

-- ArgumentsGenericite -> ArgumentGenericite SuiteArgumentsGenericite #ast;
-- #ast {
-- do
-- 	SuiteArgumentsGenericite^ast.addFirst(ArgumentGenericite^ast);
-- 	ArgumentsGenericite^ast := SuiteArgumentsGenericite^ast;
-- end
-- }

-- SuiteArgumentsGenericite -> virgule ArgumentGenericite SuiteArgumentsGenericite #ast;
-- #ast {
-- do
-- 	SuiteArgumentsGenericite1^ast.addFirst(ArgumentGenericite^ast);
-- 	SuiteArgumentsGenericite^ast := SuiteArgumentsGenericite1^ast;
-- end
-- }

-- SuiteArgumentsGenericite -> #ast;
-- #ast {
-- do
--    SuiteArgumentsGenericite^ast := new LinkedList<Type>();
-- end
-- }

-- ArgumentGenericite -> identificateur_type InstanceGenericite #ast;
-- #ast {
-- local
-- 	o : Optional<Declaration>;
-- 	d : Declaration;
-- do
-- 	if ArgumentGenericite^tds.knows(identificateur_type^txt) then
-- 		o := ArgumentGenericite^tds.get(identificateur_type^txt);
-- 		d := o.get();
-- 		match d
-- 		--Autre chose que Objet ? Type ?    --Hh j'ai ajouté extends Type pour les ArgumentsGénéricité
--                                         -- cf erreur error: incompatible types: ArgumentGenericite cannot be converted to Type
--                                         -- this.att_ast=this.att_factory.createArgumentGenericite(((Objet)loc_d));
-- 		with Objet then
-- 			if InstanceGenericite^ast = nil then
-- 				ArgumentGenericite^ast := ArgumentGenericite^factory.createArgumentGenericite(d);
-- 			else
-- 				ArgumentGenericite^ast := ArgumentGenericite^factory.createArgumentGenericite(d,InstanceGenericite^ast);
-- 			end
-- 		end
-- 	end
-- end
-- }


--TO DO
--ArgumentGenericite -> type_String ;




--------------------------------------
--l 804 > end (Tout après Expression)
--------------------------------------
-- [...]

end
