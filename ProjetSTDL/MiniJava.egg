----------------------------------------------- -*- text -*-
-- Langage MiniJava : Sous-ensemble du langage Java pour le projet STL 2016-2017
-- Sémantique : Construction de l'arbre abstrait
--                      Gestion de la table des symboles
--                      Typage
--                      Calcul des déplacements (Allocation mémoire)
--                      Génération de code TAM
-----------------------------------------------
option auto= true;
option version = 0.0.1 ;
option k=2;

inh gauche		: Expression for SuiteParametresGenericite, SuiteArgumentsGenericite;
inh factory		: BlockFactory for Type, Genericite, HeritageClasse, SuiteParametresGenericite, ImplantationInterface, ParametresGenericite, TypeAtomique, SuiteTypeAtomique,ParametreGenericite, Interfaces, Interface, HeritageInterface, SuiteHeritageInterface, ElementsInterface,ElementInterface, Signature, Classes, Classe, ElementsClasse, ElementClasse, AttributOuMethode, SuiteAttributOuMethode, Constructeur, Principale, MethodePrincipale, Bloc, Instructions, Instruction, Expression, SuiteExpressions, SuiteConditionnelle, Affectation, SuiteAffectation,Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur ;

inh tds     	: SymbolTable for Expressions, ArgumentGenericite, Programme, ParametreGenericite, Interfaces, Interface, HeritageInterface, SuiteHeritageInterface, ElementsInterface, ElementInterface, Signature, Classes, Classe, HeritageClasse, ImplantationInterface, Principale, MethodePrincipale,Genericite, ParametresGenericite, SuiteParametresGenericite, HeritageGenericite, SuiteHeritageGenericite, InstanceGenericite, ArgumentsGenericite, SuiteArgumentsGenericite, ElementClasse, ElementsClasse, Constructeur, AttributOuMethode, SuiteAttributOuMethode, Type, TypeAtomique, Parametres, Parametre, SuiteParametres, Bloc, Instructions, Instruction, Expression, SuiteExpressions, SuiteConditionnelle, Affectation, SuiteAffectation, Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, SuiteNouveau, Arguments, AppelOuAcces, Appel, Acces  ;

--inh tdsAttMet		: SymbolTable for ElementClasse, ElementsClasse, AttributOuMethode, SuiteAttributOuMethode, MethodePrincipale, Constructeur, Type, TypeAtomique, Parametres, Parametre, SuiteParametres, Bloc, Instructions, Instruction, Expression, SuiteExpressions, SuiteConditionnelle, Affectation, SuiteAffectation, Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, SuiteNouveau, Arguments, AppelOuAcces, Appel, Acces ;

--inh tdsVar		: SymbolTable for Type, TypeAtomique, Parametres, Parametre, SuiteParametres, Bloc, Instructions, Instruction, Expression, SuiteExpressions, SuiteConditionnelle, Affectation, SuiteAffectation, Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, SuiteNouveau, Arguments, AppelOuAcces, Appel, Acces ;


syn ast     : Objet for Classe, Interface;
syn ast     : LinkedList<Objet> for Interfaces,Classes;
syn ast     : Expression for Expression;
syn ast     : Type for Type, TypeAtomique, SuiteTypeAtomique, HeritageClasse, HeritageGenericite;
syn ast     : Block for Programme, Bloc, SuiteConditionnelle;
syn ast			: Instruction for Instruction;
syn ast 		: ParametreGenericite for ParametreGenericite;
syn ast     : LinkedList<ParametreGenericite> for  ParametresGenericite, Genericite, SuiteParametresGenericite;
syn ast     : LinkedList<ArgumentGenericite> for InstanceGenericite, ArgumentsGenericite, SuiteArgumentsGenericite;
syn ast     : ElementInterface for ElementInterface, Signature;
syn ast     : LinkedList<Type> for HeritageInterface, SuiteHeritageInterface;
syn ast     : LinkedList<ElementInterface> for ElementsInterface;
syn ast     : LinkedList<Parametre> for Parametres, SuiteParametres;
syn ast     : LinkedList<ElementClasse> for ElementsClasse;
syn ast     : Parametre for Parametre;
inh list    : LinkedList<Objet> for Classes, Interfaces;
inh list    : LinkedList<Instruction> for Instructions;


space separateur				is    "[\n\r\t ]+";
space commentaire				is    "\/\/.*\n";
sugar accolade_ouvrante			is    "\{";  
sugar accolade_fermante			is    "\}";  
sugar crochet_ouvrant			is    "\[";  
sugar crochet_fermant			is    "\]";  
sugar parenthese_ouvrante		is    "\(";
sugar parenthese_fermante		is    "\)";
sugar inferieur					is    "\<";  
sugar superieur					is    "\>";  
sugar inferieur_egal			is    "\<=";  
sugar superieur_egal			is    "\>=";  
sugar point						is    "\.";  
sugar point_virgule				is    ";";  
sugar virgule					is    ",";
sugar affectation				is    "=";
sugar egalite					is    "==";  
sugar different					is    "\!=";  
sugar addition					is    "\+";
sugar soustraction				is    "\-";
sugar ou						is    "\|\|";  
sugar multiplication			is    "\*";
sugar division					is    "/";
sugar modulo					is    "%";
sugar adresse					is    "&";  
sugar negation					is    "\!";  
sugar et						is    "&&";  
sugar vrai						is    "true";
sugar faux						is    "false";
sugar si						is    "if";
sugar sinon						is    "else";
sugar afficher					is    "print";  
sugar nouveau					is    "new";  
sugar tant_que					is    "while";  
sugar retour					is    "return";  
sugar type_int					is    "int";
sugar type_bool					is    "boolean";  
sugar type_char					is    "char";        
sugar type_String				is    "String";        
sugar vide						is    "void";     
sugar nul						is    "null";     
sugar choix						is    "\?";         
sugar deux_points				is    ":";          
sugar interface					is    "interface";     
sugar classe					is    "class";      
sugar extension					is    "extends";      
sugar implantation				is    "implements";      
sugar public					is    "public";    
sugar protege					is    "protected";    
sugar prive						is    "private";     
sugar statique					is    "static";       
sugar final						is    "final";       
sugar principale				is    "main";  
term   chaine					is    "\"([^\"]|\\\")*\"";  
term   caractere				is    "\'[^\']\'";  
term   entier					is    "[0-9]+";
term   identificateur			is    "[a-z_][a-zA-Z0-9_]*"; 
term   identificateur_type		is    "[A-Z][a-zA-Z0-9_]*"; 


--Programme ->#factory Interfaces #ast1 Classes #ast2 Principale #ast3;

--#factory {
--do
--  Interfaces^tds := new SymbolTable();
--  Interfaces^factory := new InterfaceFactory();
--  Interfaces^list := new LinkedList<Interface>();
--  Classes^factory := new ClassFactory();
--	Programme^tds := new SymbolTable();
--end
--}

--#ast1 {
--do
--  Classes^ast := Interfaces^ast;
--  Classes^tdsAttMet := new SymbolTable(Interface^tds);
--end
--}

--#ast2 {
--do
--  Principale^ast := Programme^ast;
--  Princiaple^tdsVar := new SymbolTable(Classes^tdsAttMet);
--end
--}

--#ast3 {
 -- do
 -- Programme^ast := Principale^ast;
 -- end
--}


Programme -> #factory Interfaces #ast3;
#factory {
do
  Interfaces^tds := new SymbolTable();
  Interfaces^factory := new InterfaceFactory();
  Interfaces^list := new LinkedList<Interface>();
  
end
}

#ast3 {
do
  Programme^ast := Interfaces^ast;
end
}

--#inh {
--do
--  BlockFactoryImpl dissociées, pb ?
--	 Interfaces^factory := new BlockFactoryImpl();
--	 Classes^factory := new BlockFactoryImpl();
--	 Principale^factory := new BlockFactoryImpl();
--	 ^tds := new SymbolTable();
--end
--}


Interfaces -> Interface Interfaces #ast;
#ast{
do
  Interfaces^list.add(Interface^ast);
  Interfaces^ast := Interfaces1^ast;
  Interfaces^tds.register(Interface^ast);
end
}


Interfaces -> #ast;
#ast {
do
  Interfaces^ast := Interfaces^list;
end
}

Interface -> interface identificateur_type Genericite HeritageInterface accolade_ouvrante ElementsInterface accolade_fermante #ast;
#ast {
do
  if (Interface^tds.knows(identificateur_type^txt)) then
    error(TYPE_already_defined, identificateur_type^txt);
  else
    if Genericite^ast = nil then
      if HeritageInterface^ast = nil then
        Interface^ast := Interface^factory.createInterface(identificateur_type^txt, ElementsInterface^ast);
      else
        Interface^ast := Interface^factory.createInterface(identificateur_type^txt,HeritageInterface^ast,ElementsInterface^ast);
      end
    else
      if HeritageInterface^ast = nil then
        Interface^ast := Interface^factory.createInterface(identificateur_type^txt,Genericite^ast,ElementsInterface^ast);
      else
        Interface^ast := Interface^factory.createInterface(identificateur_type^txt, Genericite^ast, HeritageInterface^ast, ElementsInterface^ast);
      end
    end
  end
end
}


HeritageInterface -> extension identificateur_type InstanceGenericite SuiteHeritageInterface #ast ;
#ast{
local
  o : Optional<Declaration>;
  d : Declaration;
do
  if HeritageInterface^tds.knows(identificateur_type^txt) then
    o := HeritageInterface^tds.get(identificateur_type^txt);
    d := o.get();
    match d
    with Interface then
      if InstanceGenericite^ast = nil then
        SuiteHeritageInterface^ast.add(HeritageInterface^factory.createGenericType(d));
      else
        SuiteHeritageInterface^ast.add(HeritageInterface^factory.createGenericType(d,InstanceGenericite^ast));
      HeritageInterface^ast := SuiteHeritageInterface^ast;
      end
    else
      error(TYPE_not_an_interface, identificateur_type^txt);
    end
  else
    error(TYPE_unknown,identificateur_type^txt);
  end
end
}

HeritageInterface -> #ast;
#ast{
do
  HeritageInterface^ast := nil;
end
}


SuiteHeritageInterface -> virgule identificateur_type InstanceGenericite SuiteHeritageInterface #ast;
#ast{
local
  o : Optional<Declaration>;
  d : Declaration;
do
  if SuiteHeritageInterface^tds.knows(identificateur_type^txt) then
    if SuiteHeritageInterface^tds.contains(identificateur_type^txt) then
      error(HERITAGE_already_defined,identificateur_type^txt);
    else
      o := SuiteHeritageInterface^tds.get(identificateur_type^txt);
      d := o.get();
      match d
      with Interface then
        if InstanceGenericite^ast = nil then
          SuiteHeritageInterface1^ast.add(SuiteHeritageInterface^factory.createGenericType(d));
        else
          SuiteHeritageInterface1^ast.add(SuiteHeritageInterface^factory.createGenericType(d,InstanceGenericite^ast));
        end
      else
        error(TYPE_not_an_interface,identificateur_type^txt);
      end
    end
    SuiteHeritageInterface^ast := SuiteHeritageInterface1^ast;  --Hh
  else
    error(TYPE_unknown,identificateur_type^txt);
  end
end
}


SuiteHeritageInterface -> #ast;
#ast{
do
  SuiteHeritageInterface^ast := new LinkedList<Type>();
end
}


ElementsInterface -> ElementInterface ElementsInterface #ast;
#ast{
do
  ElementsInterface1^ast.addFirst(ElementInterface^ast);
  ElementsInterface^ast := ElementsInterface1^ast;
end
}

ElementsInterface -> #ast;
#ast{
do
  ElementsInterface^ast := new LinkedList<ElementInterface>();
end
}


ElementInterface -> final statique Type identificateur affectation Expression point_virgule #ast;
#ast{
do
-- final static équivalent à une constante ?? Comment le mettre dans la bonne tds ??
  ElementInterface^ast := ElementInterface^factory.createFinalStaticField(identificateur^txt,Type^ast, Expression^ast);
end
}

ElementInterface -> Signature point_virgule #ast;
#ast{
do
  ElementInterface^ast := Signature^ast;
end
}


Signature -> vide identificateur parenthese_ouvrante Parametres parenthese_fermante #ast;
#ast{
do
  Signature^ast := Signature^factory.createSignature(identificateur^txt,Parametres^ast);
end
}  
 
Signature -> Type identificateur parenthese_ouvrante Parametres parenthese_fermante #ast;
#ast{
do
  Signature^ast := Signature^factory.createSignature(identificateur^txt,Type^ast,Parametres^ast);
end
}  


Classes -> Classe #list Classes #ast;
#ast {
do
	Classes^ast := Classes1^ast;
end
}

#list {
do
  Classes^list.add(Classe^ast);
  Classes^tds.register(Classe^ast);
end
}

Classes -> #ast;
#ast {
do
	Classes^ast := Classes^list;
end
}

Classe -> classe  identificateur_type Genericite HeritageClasse ImplantationInterface accolade_ouvrante ElementsClasse accolade_fermante #ast;
#ast {
do
  if (Classe^tds.knows(identificateur_type^txt)) then
    error(TYPE_already_defined, identificateur_type^txt);
  else
    if Genericite^ast = nil then
      if HeritageClasse^ast = nil then
        Classe^ast := Classe^factory.createClasse(identificateur_type^txt, ElementsClasse^ast);
      else
        Classe^ast := Classe^factory.createClasse(identificateur_type^txt,HeritageClasse^ast,ElementsClasse^ast);
      end
    else
      if HeritageClasse^ast = nil then
        Classe^ast := Classe^factory.createClasse(identificateur_type^txt,Genericite^ast,ElementsClasse^ast);
      else
        Classe^ast := Classe^factory.createClasse(identificateur_type^txt, Genericite^ast, HeritageClasse^ast, ElementsClasse^ast);
      end
    end
  end
end
}

HeritageClasse -> extension identificateur_type InstanceGenericite #ast ;
#ast {
do
  if HeritageClasse^tds.knows(identificateur_type^txt) then
    HeritageClasse^ast := HeritageClasse^factory.createGenericType(identificateur_type^txt,InstanceGenericite^ast);
  else
    error(TYPE_unknown,identificateur_type^txt);
  end
end
}

HeritageClasse -> #ast;
#ast {
do
  HeritageClasse^ast := nil;
end
}

ImplantationInterface -> implantation identificateur_type InstanceGenericite SuiteHeritageInterface ;

ImplantationInterface -> ;


Principale -> public classe identificateur_type accolade_ouvrante MethodePrincipale accolade_fermante ;


MethodePrincipale -> public statique vide principale parenthese_ouvrante type_String crochet_ouvrant crochet_fermant identificateur parenthese_fermante Bloc ;


Genericite -> inferieur ParametresGenericite superieur #ast ;
#ast {
do
   Genericite^ast := ParametresGenericite^ast;
end
}

Genericite -> #ast;
#ast {
do
  Genericite^ast := nil;
end
}

ParametresGenericite -> ParametreGenericite SuiteParametresGenericite #ast;
#ast {
do
  SuiteParametresGenericite^ast.addFirst(ParametreGenericite^ast);
  ParametresGenericite^ast := SuiteParametresGenericite^ast;
  ParametreGenericite^tds.register(ParametreGenericite^ast);

end
}


SuiteParametresGenericite -> virgule ParametreGenericite SuiteParametresGenericite #ast;
#ast {
do
  SuiteParametresGenericite1^ast.addFirst(ParametreGenericite^ast);
  SuiteParametresGenericite^ast := SuiteParametresGenericite1^ast;
  SuiteParametresGenericite^tds.register(ParametreGenericite^ast);
end
}
SuiteParametresGenericite -> #ast;
#ast {
do
   SuiteParametresGenericite^ast := SuiteParametresGenericite^gauche;
end
}


ParametreGenericite -> identificateur_type HeritageGenericite #ast ; 
#ast {
do
  if ParametreGenericite^tds.contains(identificateur_type^txt) then
    error(GENERICITE_already_defined, identificateur_type^txt);
  else
    ParametreGenericite^ast := ParametreGenericite^factory.createGenericParameter(identificateur_type^txt, HeritageGenericite^ast);
  end
end
} 
 
ParametreGenericite -> choix HeritageGenericite #ast ;  
#ast {
do
  ParametreGenericite^ast := ParametreGenericite^factory.createGenericParameter(HeritageGenericite^ast);
end
}
 

HeritageGenericite -> extension identificateur_type SuiteHeritageGenericite ;

HeritageGenericite -> ;

SuiteHeritageGenericite -> adresse identificateur_type SuiteHeritageGenericite ;

SuiteHeritageGenericite -> ;


InstanceGenericite -> ;

InstanceGenericite -> inferieur ArgumentsGenericite superieur ;


ArgumentsGenericite -> ArgumentGenericite SuiteArgumentsGenericite ;


SuiteArgumentsGenericite -> virgule ArgumentGenericite SuiteArgumentsGenericite ;

SuiteArgumentsGenericite -> #ast;
#ast {
do
   SuiteArgumentsGenericite^ast := SuiteArgumentsGenericite^gauche;
end
}



ArgumentGenericite -> identificateur_type InstanceGenericite ;

ArgumentGenericite -> type_String ;


ElementsClasse -> DroitAcces ElementClasse ElementsClasse ;
  
ElementsClasse -> ;  
 

DroitAcces -> public ;  
 
DroitAcces -> protege ;  
 
DroitAcces -> prive ;  
 

ElementClasse -> statique AttributOuMethode ;  
 
ElementClasse -> AttributOuMethode ;
 
ElementClasse -> Constructeur ;  
   

AttributOuMethode -> Type identificateur SuiteAttributOuMethode;

AttributOuMethode -> vide identificateur parenthese_ouvrante Parametres parenthese_fermante Bloc ;


SuiteAttributOuMethode -> point_virgule ;

SuiteAttributOuMethode -> parenthese_ouvrante Parametres parenthese_fermante Bloc ;


Constructeur -> identificateur_type parenthese_ouvrante Parametres parenthese_fermante Bloc ;
 






-- Lien entre parametres et suite de parametres ???

Parametres -> #ast ;
#ast {
do
   Parametres^ast := new LinkedList<Parametre>();
end
}

Parametres -> Parametre SuiteParametres #ast ;
#ast {
do 
   Parametres^ast.addFirst(Parametre^ast);
   Parametres^ast := SuiteParametres;  
end 
}

-- TODO
Parametre -> Type identificateur ;

SuiteParametres -> #ast;
#ast {
do
   SuiteParametres^ast := new LinkedList<Parametres>();
end
}

SuiteParametres -> virgule Parametre SuiteParametres #ast;
#ast {
do
	SuiteParametres1^ast.addFirst(Parametre^ast); 
   SuiteParametres^ast := SuiteParametres1^ast; 
end
}


Bloc -> accolade_ouvrante Instructions accolade_fermante ;
--#ast {
--do
-- Bloc^ast := Bloc^factory.createBlock(Instructions^ast);
--end
--}
--#inh {
--do
--  Instructions^list := new ArrayList<Instruction>();
--  Instructions^tds := new SymbolTable(Bloc^tds);
--end
--}


Type -> TypeAtomique SuiteTypeAtomique ;


TypeAtomique -> type_bool #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createBooleanType();  
end
}

TypeAtomique -> type_int  #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createIntegerType();  
end
}
 
TypeAtomique -> type_char #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createCharType();  
end
}

TypeAtomique -> type_String #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createStringType();  
end
}
 
TypeAtomique -> identificateur_type InstanceGenericite ; 


SuiteTypeAtomique -> crochet_ouvrant crochet_fermant SuiteTypeAtomique ;

SuiteTypeAtomique -> ;


Instructions -> #ast;
#ast {
do
   Instructions^list := new LinkedList<Instruction>();
end
}

Instructions -> Instruction Instructions #ast ;
#ast {
do
    Instructions1^list.addFirst(Instruction^ast);
    Instructions^list := Instructions1^list;
end
}


Instruction -> Type identificateur affectation Expression point_virgule ;


Instruction -> Expression point_virgule ;



Instruction -> si parenthese_ouvrante Expression parenthese_fermante Bloc SuiteConditionnelle ;


SuiteConditionnelle -> ;

SuiteConditionnelle ->sinon Bloc ;

Instruction -> tant_que parenthese_ouvrante Expression parenthese_fermante Bloc ;

Instruction -> afficher Expression point_virgule ;

Instruction -> retour Expression point_virgule ;


Expression -> Affectation SuiteAffectation ;

Affectation -> Condition SuiteCondition ;

SuiteAffectation -> affectation Expression ;

SuiteAffectation -> ;

SuiteCondition -> Comparatif Condition ;

SuiteCondition -> ;


Comparatif -> egalite ;  

Comparatif -> different ;  

Comparatif -> inferieur ;  

Comparatif -> inferieur_egal ;  

Comparatif -> superieur ;  

Comparatif -> superieur_egal ;  

   
Condition -> Terme SuiteTerme ;


SuiteTerme -> Additif Terme SuiteTerme ;  

SuiteTerme -> ;


Additif -> addition ;  

Additif -> soustraction ;  

Additif -> ou ;  


Terme -> Facteur SuiteFacteur ;


SuiteFacteur -> Multiplicatif Facteur SuiteFacteur ;  

SuiteFacteur -> ;  


Multiplicatif -> multiplication ; 

Multiplicatif -> division ; 

Multiplicatif -> modulo ; 

Multiplicatif -> et ; 

  
Facteur -> accolade_ouvrante Expressions accolade_fermante ;


Expressions -> Expression SuiteExpressions ;

SuiteExpressions -> virgule Expression SuiteExpressions ;

SuiteExpressions -> ;


Facteur -> soustraction Facteur ;  

Facteur -> negation Facteur ;  

Facteur -> nouveau Type SuiteNouveau ;


SuiteNouveau -> crochet_ouvrant Expression crochet_fermant ;

SuiteNouveau -> Arguments ;

Arguments -> parenthese_ouvrante parenthese_fermante ;

Arguments -> parenthese_ouvrante Expressions parenthese_fermante ;


Facteur -> Valeur ;

 
Valeur -> entier ;

Valeur -> vrai ;

Valeur -> faux ;

Valeur -> chaine ;

Valeur -> caractere ;


Facteur -> identificateur AppelOuAcces ;

Facteur -> identificateur_type point identificateur AppelOuAcces ;

Facteur -> parenthese_ouvrante Expression parenthese_fermante ;

AppelOuAcces -> Acces ;

AppelOuAcces -> Appel ;


Acces -> ;

Acces -> crochet_ouvrant Expression crochet_fermant Acces ;

Acces -> point identificateur AppelOuAcces ;


Appel -> Arguments Acces ;  
 
end
