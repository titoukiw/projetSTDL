----------------------------------------------- -*- text -*-
-- Langage MiniJava : Sous-ensemble du langage Java pour le projet STL 2016-2017
-- Sémantique : Construction de l'arbre abstrait
--                      Gestion de la table des symboles
--                      Typage
--                      Calcul des déplacements (Allocation mémoire)
--                      Génération de code TAM
-----------------------------------------------
option auto= true;
option version = 0.0.1 ;
option k=2;

inh gauche		: Expression for SuiteParametresGenericite, SuiteArgumentsGenericite;

syn ast 		: Fichier for Classes, Classe, Principale, Interface, Interfaces;
syn ast			: Instruction for Instruction;
syn ast 		: Parametre for Parametre, ParametreGenericite;

syn parametres	: Parametre for Parametre, ParametresGenericite, SuiteParametre;

syn list        : LinkedList<Interface> for Interfaces;
syn list        : LinkedList<Classe> for Classes;
syn list        : LinkedList<Instruction> for Instructions;


space separateur				is    "[\n\r\t ]+";
space commentaire				is    "\/\/.*\n";
sugar accolade_ouvrante			is    "\{";  
sugar accolade_fermante			is    "\}";  
sugar crochet_ouvrant			is    "\[";  
sugar crochet_fermant			is    "\]";  
sugar parenthese_ouvrante		is    "\(";
sugar parenthese_fermante		is    "\)";
sugar inferieur					is    "\<";  
sugar superieur					is    "\>";  
sugar inferieur_egal			is    "\<=";  
sugar superieur_egal			is    "\>=";  
sugar point						is    "\.";  
sugar point_virgule				is    ";";  
sugar virgule					is    ",";
sugar affectation				is    "=";
sugar egalite					is    "==";  
sugar different					is    "\!=";  
sugar addition					is    "\+";
sugar soustraction				is    "\-";
sugar ou						is    "\|\|";  
sugar multiplication			is    "\*";
sugar division					is    "/";
sugar modulo					is    "%";
sugar adresse					is    "&";  
sugar negation					is    "\!";  
sugar et						is    "&&";  
sugar vrai						is    "true";
sugar faux						is    "false";
sugar si						is    "if";
sugar sinon						is    "else";
sugar afficher					is    "print";  
sugar nouveau					is    "new";  
sugar tant_que					is    "while";  
sugar retour					is    "return";  
sugar type_int					is    "int";
sugar type_bool					is    "boolean";  
sugar type_float				is    "float";  
sugar type_char					is    "char";        
sugar type_String				is    "String";        
sugar vide						is    "void";     
sugar nul						is    "null";     
sugar choix						is    "\?";         
sugar deux_points				is    ":";          
sugar interface					is    "interface";     
sugar classe					is    "class";      
sugar extension					is    "extends";      
sugar implantation				is    "implements";      
sugar public					is    "public";    
sugar protege					is    "protected";    
sugar prive						is    "private";     
sugar statique					is    "static";       
sugar final						is    "final";       
sugar principale				is    "main";  

term   chaine					is    "\"([^\"]|\\\")*\"";  
term   caractere				is    "\'[^\']\'";  
term   entier					is    "[0-9]+";
term   identificateur			is    "[a-z_][a-zA-Z0-9_]*"; 
term   identificateur_type		is    "[A-Z][a-zA-Z0-9_]*"; 


Programme -> Interfaces Classes Principale #inh;
#inh {
do
	-- Bloc^factory := new BlockFactoryImpl();
	-- ^ := new ProgrammeFactoryImpl();
end
}


Interfaces -> Interface Interfaces #ast;
#ast {
do
	Interfaces1^list.add(Interface^ast);
	Interfaces^list := Interfaces1^list;
end
}

Interfaces -> #ast;
#ast {
do
Interfaces^list := new LinkedList<Interface>();
end
}

Interface -> interface identificateur_type Genericite HeritageInterface accolade_ouvrante ElementsInterface accolade_fermante ;


HeritageInterface -> extension identificateur_type InstanceGenericite SuiteHeritageInterface ;

HeritageInterface -> ;


SuiteHeritageInterface -> virgule identificateur_type InstanceGenericite SuiteHeritageInterface ;

SuiteHeritageInterface -> ;


ElementsInterface -> ElementInterface ElementsInterface ;

ElementsInterface -> ;


ElementInterface -> final statique Type identificateur affectation Expression point_virgule ;

ElementInterface -> Signature point_virgule ;


Signature -> vide identificateur parenthese_ouvrante Parametres parenthese_fermante ;  
 
Signature -> Type identificateur parenthese_ouvrante Parametres parenthese_fermante ;  


Classes -> Classe Classes #ast;
#ast {
do
	Classes1^list.add(Classe^ast);
	Classes^list := Classes1^list;
end
}

Classes -> #ast;
#ast {
do
	Classes^list := new LinkedList<Classe>();
end
}

Classe -> classe  identificateur_type Genericite HeritageClasse ImplantationInterface accolade_ouvrante ElementsClasse accolade_fermante ;


HeritageClasse -> extension identificateur_type InstanceGenericite ;

HeritageClasse -> ;

ImplantationInterface -> implantation identificateur_type InstanceGenericite SuiteHeritageInterface ;

ImplantationInterface -> ;


Principale -> public classe identificateur_type accolade_ouvrante MethodePrincipale accolade_fermante ;


MethodePrincipale -> public statique vide principale parenthese_ouvrante type_String crochet_ouvrant crochet_fermant identificateur parenthese_fermante Bloc ;


Genericite -> inferieur ParametresGenericite superieur #ast ;
#ast {
do
   Generecite^parametres.add(ParametreGenericite^ast);
   Genericite^parametres := Genericite^parametres;
end
}

Genericite -> ;


ParametresGenericite -> ParametreGenericite SuiteParametresGenericite ;


SuiteParametresGenericite -> virgule ParametreGenericite SuiteParametresGenericite ;

SuiteParametresGenericite -> #ast;
#ast {
do
   SuiteParametresGenericite^ast := SuiteParametresGenericite^gauche;
end
}


ParametreGenericite -> identificateur_type HeritageGenericite ;  
 
ParametreGenericite -> choix HeritageGenericite ;  
 

HeritageGenericite -> extension identificateur_type SuiteHeritageGenericite ;

HeritageGenericite -> ;

SuiteHeritageGenericite -> adresse identificateur_type SuiteHeritageGenericite ;

SuiteHeritageGenericite -> ;


InstanceGenericite -> ;

InstanceGenericite -> inferieur ArgumentsGenericite superieur ;


ArgumentsGenericite -> ArgumentGenericite SuiteArgumentsGenericite ;


SuiteArgumentsGenericite -> virgule ArgumentGenericite SuiteArgumentsGenericite ;

SuiteArgumentsGenericite -> #ast;
#ast {
do
   SuiteArgumentsGenericite^ast := SuiteArgumentsGenericite^gauche;
end
}



ArgumentGenericite -> identificateur_type InstanceGenericite ;

ArgumentGenericite -> type_String ;


ElementsClasse -> DroitAcces ElementClasse ElementsClasse ;
  
ElementsClasse -> ;  
 

DroitAcces -> public ;  
 
DroitAcces -> protege ;  
 
DroitAcces -> prive ;  
 

ElementClasse -> statique AttributOuMethode ;  
 
ElementClasse -> AttributOuMethode ;
 
ElementClasse -> Constructeur ;  
   

AttributOuMethode -> Type identificateur SuiteAttributOuMethode;

AttributOuMethode -> vide identificateur parenthese_ouvrante Parametres parenthese_fermante Bloc ;


SuiteAttributOuMethode -> point_virgule ;

SuiteAttributOuMethode -> parenthese_ouvrante Parametres parenthese_fermante Bloc ;


Constructeur -> identificateur_type parenthese_ouvrante Parametres parenthese_fermante Bloc ;
 






-- Lien entre parametres et suite de parametres ???

Parametres -> #ast ;
#ast {
do
   Parametres^parametres := new LinkedList<Parametre>();
end
}

Parametres -> Parametre SuiteParametres #ast ;
#ast {
do 
   Parametres^parametres.addFirst(Parametre^ast); 
   Parametres^parametres := Parametres^parametres; 
end 
}

-- TODO
Parametre -> Type identificateur ;

SuiteParametres -> ;
#ast {
do
   SuiteParametres^parametres := new LinkedList<Parametres>();
end
}

SuiteParametres -> virgule Parametre SuiteParametres #ast;
#ast {
do
	SuiteParametres1^parametres.addFirst(Parametre^ast); 
   SuiteParametres^parametres := SuiteParametres1^parametres; 
end
}


Bloc -> accolade_ouvrante #inh Instructions accolade_fermante #ast ;
#ast {
do
  Bloc^ast := Bloc^factory.createBlock(Instructions^ast);
end
}
#inh {
do
  Instructions^tds := new SymbolTable(Bloc^tds);
end
}


Type -> TypeAtomique SuiteTypeAtomique ;


TypeAtomique -> type_bool #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createBooleanType();  
end
}

TypeAtomique -> type_int  #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createIntegerType();  
end
}
 
TypeAtomique -> type_char #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createCharType();  
end
}
 
TypeAtomique -> type_float #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createFloatType();  
end
}

TypeAtomique -> type_String #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createStringType();  
end
}
 
TypeAtomique -> identificateur_type InstanceGenericite ; 


SuiteTypeAtomique -> crochet_ouvrant crochet_fermant SuiteTypeAtomique ;

SuiteTypeAtomique -> ;


Instructions -> #ast;
#ast {
do
   Instructions^list := new LinkedList<Instruction>();
end
}

Instructions -> Instruction Instructions #ast ;
#ast {
do
    Instructions1^list.addFirst(Instruction^ast);
    Instructions^list := Instructions1^list;
end
}


Instruction -> Type identificateur affectation Expression point_virgule ;


Instruction -> Affectable affectation Expression point_virgule ;


Affectable -> parenthese_ouvrante Affectable parenthese_fermante ;

Affectable -> identificateur SuiteAffectable ;


SuiteAffectable -> ;

SuiteAffectable -> point identificateur AppelOuAcces ;

SuiteAffectable -> crochet_ouvrant Expression crochet_fermant SuiteAffectable ;



Instruction -> si parenthese_ouvrante Expression parenthese_fermante Bloc SuiteConditionnelle ;


SuiteConditionnelle -> ;

SuiteConditionnelle ->sinon Bloc ;

Instruction -> tant_que parenthese_ouvrante Expression parenthese_fermante Bloc ;

Instruction -> afficher Expression point_virgule ;

Instruction -> retour Expression point_virgule ;


Expression -> Condition #inh SuiteCondition #ast ;
#inh {
do
   SuiteCondition^gauche := Condition^ast ;
end 
}
#ast {
do
    Expression^ast := SuiteCondition^ast;
end 
}

SuiteCondition -> Comparatif Condition ;

SuiteCondition -> ;


Comparatif -> egalite ;  

Comparatif -> different ;  

Comparatif -> inferieur ;  

Comparatif -> inferieur_egal ;  

Comparatif -> superieur ;  

Comparatif -> superieur_egal ;  

   
Condition -> Terme SuiteTerme ;


SuiteTerme -> Additif Terme SuiteTerme ;  

SuiteTerme -> ;


Additif -> addition ;  

Additif -> soustraction ;  

Additif -> ou ;  


Terme -> Facteur SuiteFacteur ;


SuiteFacteur -> Multiplicatif Facteur SuiteFacteur ;  

SuiteFacteur -> ;  


Multiplicatif -> multiplication ; 

Multiplicatif -> division ; 

Multiplicatif -> modulo ; 

Multiplicatif -> et ; 

  
Facteur -> accolade_ouvrante Expressions accolade_fermante ;


Expressions -> Expression SuiteExpressions ;

SuiteExpressions -> virgule Expression SuiteExpressions ;

SuiteExpressions -> ;


Facteur -> soustraction Facteur ;  

Facteur -> negation Facteur ;  

Facteur -> nouveau Type SuiteNouveau ;


SuiteNouveau -> crochet_ouvrant Expression crochet_fermant ;

-- A enlever d'après le forum : SuiteNouveau -> ;


Facteur -> Valeur ;

 
Valeur -> entier ;

Valeur -> vrai ;

Valeur -> faux ;

Valeur -> chaine ;

Valeur -> caractere ;


Facteur -> identificateur AppelOuAcces ;


AppelOuAcces -> Acces ;

AppelOuAcces -> Appel ;


Acces -> ;

Acces -> crochet_ouvrant Expression crochet_fermant Acces ;

Acces -> point identificateur AppelOuAcces ;


Appel -> parenthese_ouvrante parenthese_fermante Acces ;  
 
Appel -> parenthese_ouvrante Expressions parenthese_fermante Acces ;  
 
end
